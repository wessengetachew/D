
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematical Discovery Platform</title>
    
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/decimal.js@10.4.3/decimal.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    
    <style>
        /* Complete CSS with all styles */
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #9b59b6;
            --text-color: #333;
            --bg-color: #fff;
            --bg-secondary: #f8f9fa;
            --border-color: #dee2e6;
            --shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .tab-btn.active {
            background: var(--secondary-color);
            color: white;
            border-color: var(--secondary-color);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .control-panel {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        
        .value-display {
            min-width: 60px;
            font-weight: 600;
            color: var(--secondary-color);
        }
        
        .visualization-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .viz-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }
        
        .viz-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: var(--primary-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }
        
        #canvas2d, #canvas3d-container {
            width: 100%;
            height: 500px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: white;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid var(--secondary-color);
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .data-table th, .data-table td {
            padding: 12px;
            text-align: center;
            border: 1px solid var(--border-color);
        }
        
        .data-table th {
            background: var(--primary-color);
            color: white;
        }
        
        .data-table tr:nth-child(even) {
            background: var(--bg-secondary);
        }
        
        .export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .export-btn {
            padding: 10px 20px;
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
        }
        
        .export-btn:hover {
            background: #8e44ad;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        @media (max-width: 768px) {
            .visualization-container {
                grid-template-columns: 1fr;
            }
            
            #canvas2d, #canvas3d-container {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Mathematical Discovery Platform</h1>
            <p>Interactive visualization of primitive lattice points, zeta function, and boundary phenomena</p>
            <p style="opacity: 0.8; font-size: 0.9rem; margin-top: 10px;">
                Author: Wessen Getachew • Twitter: @7dview
            </p>
        </div>
        
        <!-- Main Control Panel -->
        <div class="control-panel" id="mainControls">
            <div class="control-group">
                <label>Zeta Parameter (s):</label>
                <div class="slider-container">
                    <input type="range" id="zetaS" min="1.1" max="5" step="0.1" value="2">
                    <span class="value-display" id="zetaValue">s = 2</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Radius (R):</label>
                <div class="slider-container">
                    <input type="range" id="radiusR" min="10" max="200" step="5" value="50">
                    <span class="value-display" id="radiusValue">R = 50</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Dimension (k):</label>
                <div class="slider-container">
                    <input type="range" id="dimensionK" min="2" max="6" step="1" value="3">
                    <span class="value-display" id="dimensionValue">k = 3</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>Precision Mode:</label>
                <select id="precisionMode">
                    <option value="standard">Standard Precision</option>
                    <option value="high">High Precision (Decimal.js)</option>
                </select>
            </div>
        </div>
        
        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="theory">Theory & Explorer</button>
            <button class="tab-btn" data-tab="viz2d">2D Visualization</button>
            <button class="tab-btn" data-tab="viz3d">3D Visualization</button>
            <button class="tab-btn" data-tab="analysis">Analysis & Data</button>
            <button class="tab-btn" data-tab="export">Export</button>
        </div>
        
        <!-- Tab Contents -->
        <div id="theory" class="tab-content active">
            <div class="viz-card">
                <h2 class="viz-title">Theory Explorer</h2>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <div>
                        <h3>Mathematical Foundation</h3>
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <p><strong>Primitive Lattice Points:</strong></p>
                            <p>Points \((x_1, x_2, \ldots, x_k) \in \mathbb{Z}^k\) with \(\gcd(x_1, \ldots, x_k) = 1\)</p>
                            <p>\[N_k^{\text{prim}}(R) = \sum_{d=1}^{\lfloor R \rfloor} \mu(d) \cdot N_k\left(\frac{R}{d}\right)\]</p>
                        </div>
                        
                        <div style="background: #e8f4fd; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <p><strong>Zeta Function Relationship:</strong></p>
                            <p>\[N_k^{\text{prim}}(R) \sim \frac{V_k(R)}{\zeta(s)}\]
                            where \(V_k(R) = \frac{\pi^{k/2}}{\Gamma(k/2 + 1)} R^k\)</p>
                        </div>
                    </div>
                    
                    <div>
                        <h3>Live Calculations</h3>
                        <div class="stats-grid" id="theoryStats">
                            <!-- Filled by JavaScript -->
                        </div>
                        
                        <h3 style="margin-top: 20px;">Empirical Validation</h3>
                        <div id="empiricalResults" style="background: #fff; padding: 15px; border-radius: 8px; border: 1px solid #ddd;">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        <th>Metric</th>
                                        <th>Value</th>
                                        <th>Error</th>
                                    </tr>
                                </thead>
                                <tbody id="validationTable">
                                    <!-- Filled by JavaScript -->
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 2D Visualization -->
        <div id="viz2d" class="tab-content">
            <div class="visualization-container">
                <div class="viz-card">
                    <h2 class="viz-title">2D Lattice Visualization</h2>
                    <canvas id="canvas2d"></canvas>
                    
                    <div class="control-panel" style="margin-top: 15px;">
                        <div class="control-group">
                            <label>Point Size:</label>
                            <input type="range" id="pointSize2d" min="1" max="10" value="4">
                        </div>
                        <div class="control-group">
                            <label>Grid Opacity:</label>
                            <input type="range" id="gridOpacity" min="0" max="100" value="30">
                        </div>
                        <div class="control-group">
                            <label>
                                <input type="checkbox" id="showBoundary" checked>
                                Show Boundary
                            </label>
                        </div>
                    </div>
                    
                    <div class="stats-grid" id="stats2d">
                        <!-- Filled by JavaScript -->
                    </div>
                </div>
                
                <div class="viz-card">
                    <h2 class="viz-title">Point Inspector</h2>
                    <div id="pointInspector" style="height: 400px; overflow-y: auto; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <p>Click on any point in the 2D visualization to inspect details.</p>
                        <div id="pointDetails"></div>
                    </div>
                    
                    <div style="margin-top: 20px;">
                        <h3>Selected Point Analysis</h3>
                        <div id="selectedPointAnalysis"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 3D Visualization -->
        <div id="viz3d" class="tab-content">
            <div class="viz-card">
                <h2 class="viz-title">3D Lattice Visualization</h2>
                <div id="canvas3d-container">
                    <!-- Three.js canvas will be inserted here -->
                </div>
                
                <div class="control-panel" style="margin-top: 15px;">
                    <div class="control-group">
                        <label>3D Point Size:</label>
                        <input type="range" id="pointSize3d" min="0.1" max="2" step="0.1" value="0.5">
                    </div>
                    <div class="control-group">
                        <label>Rotation Speed:</label>
                        <input type="range" id="rotationSpeed" min="0" max="5" step="0.5" value="1">
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="autoRotate" checked>
                            Auto Rotate
                        </label>
                    </div>
                    <div class="control-group">
                        <label>
                            <input type="checkbox" id="showAxes" checked>
                            Show Axes
                        </label>
                    </div>
                </div>
                
                <div class="stats-grid" id="stats3d">
                    <!-- Filled by JavaScript -->
                </div>
            </div>
        </div>
        
        <!-- Analysis & Data -->
        <div id="analysis" class="tab-content">
            <div class="viz-card">
                <h2 class="viz-title">Error Analysis</h2>
                <canvas id="errorChart" height="300"></canvas>
                
                <div class="control-panel" style="margin-top: 15px;">
                    <div class="control-group">
                        <label>Error Type:</label>
                        <select id="errorType">
                            <option value="absolute">Absolute Error</option>
                            <option value="relative">Relative Error (%)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Chart Type:</label>
                        <select id="chartType">
                            <option value="line">Line Chart</option>
                            <option value="bar">Bar Chart</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="viz-card" style="margin-top: 20px;">
                <h2 class="viz-title">Systematic Data Analysis</h2>
                <table class="data-table" id="systematicData">
                    <thead>
                        <tr>
                            <th>R</th>
                            <th>N(R)</th>
                            <th>N_prim(R)</th>
                            <th>Theoretical</th>
                            <th>Error</th>
                            <th>Error %</th>
                            <th>Boundary Points</th>
                        </tr>
                    </thead>
                    <tbody id="dataTableBody">
                        <!-- Filled by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Export -->
        <div id="export" class="tab-content">
            <div class="viz-card">
                <h2 class="viz-title">Export Visualizations</h2>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0;">
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                        <h3>2D Visualization</h3>
                        <div class="export-buttons">
                            <button class="export-btn" onclick="export2D('png')">Export as PNG</button>
                            <button class="export-btn" onclick="export2D('svg')">Export as SVG</button>
                            <button class="export-btn" onclick="export2DData()">Export Data (CSV)</button>
                        </div>
                        <p style="margin-top: 10px; font-size: 0.9rem; color: #666;">
                            Exports the current 2D lattice visualization
                        </p>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                        <h3>3D Visualization</h3>
                        <div class="export-buttons">
                            <button class="export-btn" onclick="export3D('png')">Export as PNG</button>
                            <button class="export-btn" onclick="capture3DView()">Capture Current View</button>
                        </div>
                        <p style="margin-top: 10px; font-size: 0.9rem; color: #666;">
                            Exports the 3D visualization from current viewpoint
                        </p>
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                        <h3>Charts & Data</h3>
                        <div class="export-buttons">
                            <button class="export-btn" onclick="exportChart('png')">Export Chart</button>
                            <button class="export-btn" onclick="exportAllData()">Export All Data (JSON)</button>
                            <button class="export-btn" onclick="exportAnalysisReport()">Export Report (PDF)</button>
                        </div>
                        <p style="margin-top: 10px; font-size: 0.9rem; color: #666;">
                            Export analysis charts and complete dataset
                        </p>
                    </div>
                </div>
                
                <div style="margin-top: 30px; padding: 20px; background: #e8f4fd; border-radius: 8px;">
                    <h3>Batch Export</h3>
                    <div class="export-buttons">
                        <button class="export-btn" onclick="batchExport()">Export Everything (ZIP)</button>
                    </div>
                    <p style="margin-top: 10px; font-size: 0.9rem; color: #666;">
                        Creates a ZIP file containing all visualizations, data, and analysis
                    </p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main JavaScript -->
    <script>
        // ===== GLOBAL STATE =====
        const state = {
            zetaS: 2,
            radiusR: 50,
            dimensionK: 3,
            highPrecision: false,
            
            // Caches
            mobiusCache: new Map(),
            gcdCache: new Map(),
            pointCache: new Map(),
            
            // Visualization states
            threeScene: null,
            threeRenderer: null,
            threeCamera: null,
            threeObjects: [],
            chart: null,
            currentPoint: null
        };
        
        // ===== INITIALIZATION =====
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    
                    this.classList.add('active');
                    document.getElementById(this.dataset.tab).classList.add('active');
                    
                    // Initialize specific tab content
                    if (this.dataset.tab === 'viz2d' && !window.canvas2dInitialized) {
                        init2DVisualization();
                    } else if (this.dataset.tab === 'viz3d' && !window.threeInitialized) {
                        init3DVisualization();
                    } else if (this.dataset.tab === 'analysis' && !window.chartInitialized) {
                        initChart();
                    }
                });
            });
            
            // Initialize controls
            initControls();
            
            // Initialize 2D visualization
            init2DVisualization();
            
            // Initialize theory explorer
            updateTheoryExplorer();
            
            console.log('Platform initialized successfully!');
        });
        
        // ===== CONTROL INITIALIZATION =====
        function initControls() {
            // Zeta parameter
            const zetaSlider = document.getElementById('zetaS');
            const zetaValue = document.getElementById('zetaValue');
            
            zetaSlider.addEventListener('input', function() {
                state.zetaS = parseFloat(this.value);
                zetaValue.textContent = `s = ${this.value}`;
                updateAllVisualizations();
            });
            
            // Radius
            const radiusSlider = document.getElementById('radiusR');
            const radiusValue = document.getElementById('radiusValue');
            
            radiusSlider.addEventListener('input', function() {
                state.radiusR = parseInt(this.value);
                radiusValue.textContent = `R = ${this.value}`;
                updateAllVisualizations();
            });
            
            // Dimension
            const dimSlider = document.getElementById('dimensionK');
            const dimValue = document.getElementById('dimensionValue');
            
            dimSlider.addEventListener('input', function() {
                state.dimensionK = parseInt(this.value);
                dimValue.textContent = `k = ${this.value}`;
                updateAllVisualizations();
            });
            
            // Precision mode
            document.getElementById('precisionMode').addEventListener('change', function() {
                state.highPrecision = this.value === 'high';
                updateAllVisualizations();
            });
            
            // 2D controls
            document.getElementById('pointSize2d').addEventListener('input', function() {
                if (window.canvas2dInitialized) {
                    draw2DLattice();
                }
            });
            
            document.getElementById('gridOpacity').addEventListener('input', function() {
                if (window.canvas2dInitialized) {
                    draw2DLattice();
                }
            });
            
            document.getElementById('showBoundary').addEventListener('change', function() {
                if (window.canvas2dInitialized) {
                    draw2DLattice();
                }
            });
        }
        
        // ===== MATHEMATICAL FUNCTIONS =====
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            
            const key = `${a},${b}`;
            if (state.gcdCache.has(key)) {
                return state.gcdCache.get(key);
            }
            
            while (b) {
                [a, b] = [b, a % b];
            }
            
            state.gcdCache.set(key, a);
            return a;
        }
        
        function gcdArray(arr) {
            if (arr.length === 0) return 0;
            if (arr.length === 1) return Math.abs(arr[0]);
            
            let result = Math.abs(arr[0]);
            for (let i = 1; i < arr.length; i++) {
                result = gcd(result, Math.abs(arr[i]));
                if (result === 1) break;
            }
            return result;
        }
        
        function mobius(n) {
            if (n <= 0) return 0;
            if (n === 1) return 1;
            
            if (state.mobiusCache.has(n)) {
                return state.mobiusCache.get(n);
            }
            
            // Check for square factors
            let temp = n;
            for (let i = 2; i * i <= n; i++) {
                if (n % (i * i) === 0) {
                    state.mobiusCache.set(n, 0);
                    return 0;
                }
            }
            
            // Count prime factors
            let primeFactors = 0;
            temp = n;
            for (let i = 2; i * i <= temp; i++) {
                if (temp % i === 0) {
                    primeFactors++;
                    temp /= i;
                    if (temp % i === 0) {
                        state.mobiusCache.set(n, 0);
                        return 0;
                    }
                }
            }
            if (temp > 1) primeFactors++;
            
            const result = (primeFactors % 2 === 0) ? 1 : -1;
            state.mobiusCache.set(n, result);
            return result;
        }
        
        function computeZeta(s) {
            // Approximate Riemann zeta function
            if (s === 2) return Math.PI * Math.PI / 6;
            if (s === 4) return Math.pow(Math.PI, 4) / 90;
            if (s === 6) return Math.pow(Math.PI, 6) / 945;
            
            let sum = 0;
            const terms = 1000;
            for (let n = 1; n <= terms; n++) {
                sum += 1 / Math.pow(n, s);
            }
            return sum;
        }
        
        function computeVolume(k, R) {
            // Volume of k-dimensional sphere
            const pi = Math.PI;
            const gamma = gammaFunction(k/2 + 1);
            return Math.pow(pi, k/2) / gamma * Math.pow(R, k);
        }
        
        function gammaFunction(x) {
            // Lanczos approximation
            const p = [
                0.99999999999980993, 676.5203681218851, -1259.1392167224028,
                771.32342877765313, -176.61502916214059, 12.507343278686905,
                -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7
            ];
            
            if (x < 0.5) {
                return Math.PI / (Math.sin(Math.PI * x) * gammaFunction(1 - x));
            }
            
            x -= 1;
            let a = p[0];
            const t = x + 7.5;
            
            for (let i = 1; i < p.length; i++) {
                a += p[i] / (x + i);
            }
            
            return Math.sqrt(2 * Math.PI) * Math.pow(t, x + 0.5) * Math.exp(-t) * a;
        }
        
        function computeNPrimitive(k, R) {
            // Count primitive lattice points using Möbius inversion
            let sum = 0;
            const maxD = Math.floor(R);
            
            for (let d = 1; d <= maxD; d++) {
                const mu = mobius(d);
                if (mu !== 0) {
                    // Approximate number of lattice points in sphere of radius R/d
                    const Nk = Math.round(computeVolume(k, R/d));
                    sum += mu * Nk;
                }
            }
            
            return Math.round(sum);
        }
        
        function countActualPrimitivePoints(k, R) {
            // For 2D and 3D, we can actually count
            if (k === 2) {
                let count = 0;
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R) {
                            if (gcd(Math.abs(x), Math.abs(y)) === 1) {
                                count++;
                            }
                        }
                    }
                }
                return count;
            } else if (k === 3) {
                let count = 0;
                const R2 = R*R;
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        for (let z = -R; z <= R; z++) {
                            if (x*x + y*y + z*z <= R2) {
                                if (gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]) === 1) {
                                    count++;
                                }
                            }
                        }
                    }
                }
                return count;
            }
            
            // For higher dimensions, use approximation
            return Math.round(computeVolume(k, R) / computeZeta(k));
        }
        
        // ===== THEORY EXPLORER =====
        function updateTheoryExplorer() {
            const k = state.dimensionK;
            const R = state.radiusR;
            const s = state.zetaS;
            
            // Calculate values
            const volume = computeVolume(k, R);
            const zetaValue = computeZeta(s);
            const theoretical = volume / zetaValue;
            const actual = countActualPrimitivePoints(k, R);
            const error = Math.abs(theoretical - actual);
            const errorPercent = (error / theoretical * 100).toFixed(3);
            
            // Update theory stats
            const statsGrid = document.getElementById('theoryStats');
            statsGrid.innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Volume V_${k}(R)</div>
                    <div class="stat-value">${volume.toFixed(2)}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">ζ(${s})</div>
                    <div class="stat-value">${zetaValue.toFixed(6)}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Theoretical N</div>
                    <div class="stat-value">${Math.round(theoretical)}</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Actual N</div>
                    <div class="stat-value">${actual}</div>
                </div>
            `;
            
            // Update empirical validation table
            const validationTable = document.getElementById('validationTable');
            validationTable.innerHTML = `
                <tr>
                    <td>Theoretical Prediction</td>
                    <td>${Math.round(theoretical)}</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>Actual Count</td>
                    <td>${actual}</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>Absolute Error</td>
                    <td>${error.toFixed(2)}</td>
                    <td>${errorPercent}%</td>
                </tr>
                <tr>
                    <td>Volume Ratio</td>
                    <td>${(actual / volume * 100).toFixed(3)}%</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>ζ(s) Effect</td>
                    <td>${(1/zetaValue * 100).toFixed(3)}%</td>
                    <td>-</td>
                </tr>
            `;
        }
        
        // ===== 2D VISUALIZATION =====
        let canvas2d, ctx2d;
        
        function init2DVisualization() {
            canvas2d = document.getElementById('canvas2d');
            if (!canvas2d) return;
            
            ctx2d = canvas2d.getContext('2d');
            canvas2d.width = canvas2d.clientWidth;
            canvas2d.height = 500;
            
            // Add click handler
            canvas2d.addEventListener('click', handle2DClick);
            
            draw2DLattice();
            window.canvas2dInitialized = true;
        }
        
        function draw2DLattice() {
            if (!ctx2d) return;
            
            const R = state.radiusR;
            const centerX = canvas2d.width / 2;
            const centerY = canvas2d.height / 2;
            const scale = Math.min(canvas2d.width, canvas2d.height) / (R * 2 + 2);
            const pointSize = parseInt(document.getElementById('pointSize2d').value);
            const gridOpacity = parseInt(document.getElementById('gridOpacity').value) / 100;
            const showBoundary = document.getElementById('showBoundary').checked;
            
            // Clear canvas
            ctx2d.fillStyle = 'white';
            ctx2d.fillRect(0, 0, canvas2d.width, canvas2d.height);
            
            // Draw grid
            if (gridOpacity > 0) {
                ctx2d.strokeStyle = `rgba(200, 200, 200, ${gridOpacity})`;
                ctx2d.lineWidth = 1;
                
                // Vertical lines
                for (let x = -R; x <= R; x++) {
                    const screenX = centerX + x * scale;
                    ctx2d.beginPath();
                    ctx2d.moveTo(screenX, 0);
                    ctx2d.lineTo(screenX, canvas2d.height);
                    ctx2d.stroke();
                }
                
                // Horizontal lines
                for (let y = -R; y <= R; y++) {
                    const screenY = centerY + y * scale;
                    ctx2d.beginPath();
                    ctx2d.moveTo(0, screenY);
                    ctx2d.lineTo(canvas2d.width, screenY);
                    ctx2d.stroke();
                }
            }
            
            // Draw axes
            ctx2d.strokeStyle = '#666';
            ctx2d.lineWidth = 2;
            ctx2d.beginPath();
            ctx2d.moveTo(centerX, 0);
            ctx2d.lineTo(centerX, canvas2d.height);
            ctx2d.stroke();
            ctx2d.beginPath();
            ctx2d.moveTo(0, centerY);
            ctx2d.lineTo(canvas2d.width, centerY);
            ctx2d.stroke();
            
            // Draw circle boundary
            ctx2d.strokeStyle = '#3498db';
            ctx2d.lineWidth = 2;
            ctx2d.beginPath();
            ctx2d.arc(centerX, centerY, R * scale, 0, Math.PI * 2);
            ctx2d.stroke();
            
            // Count and draw points
            let totalPoints = 0;
            let primitivePoints = 0;
            let boundaryPoints = 0;
            
            for (let x = -R; x <= R; x++) {
                for (let y = -R; y <= R; y++) {
                    const distance = Math.sqrt(x*x + y*y);
                    if (distance <= R) {
                        totalPoints++;
                        
                        const screenX = centerX + x * scale;
                        const screenY = centerY + y * scale;
                        const isPrimitive = gcd(Math.abs(x), Math.abs(y)) === 1;
                        const isBoundary = showBoundary && Math.abs(distance - R) < 1;
                        
                        if (isPrimitive) primitivePoints++;
                        if (isBoundary) boundaryPoints++;
                        
                        // Set color
                        ctx2d.fillStyle = isPrimitive ? '#3498db' : '#e74c3c';
                        
                        // Draw point
                        ctx2d.beginPath();
                        ctx2d.arc(screenX, screenY, pointSize / 2, 0, Math.PI * 2);
                        ctx2d.fill();
                        
                        // Highlight boundary
                        if (isBoundary) {
                            ctx2d.strokeStyle = '#27ae60';
                            ctx2d.lineWidth = 2;
                            ctx2d.beginPath();
                            ctx2d.arc(screenX, screenY, pointSize / 2 + 2, 0, Math.PI * 2);
                            ctx2d.stroke();
                        }
                    }
                }
            }
            
            // Update statistics
            const stats2d = document.getElementById('stats2d');
            if (stats2d) {
                stats2d.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">Total Points</div>
                        <div class="stat-value">${totalPoints}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Primitive Points</div>
                        <div class="stat-value">${primitivePoints}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Primitive Ratio</div>
                        <div class="stat-value">${((primitivePoints/totalPoints)*100).toFixed(1)}%</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Boundary Points</div>
                        <div class="stat-value">${boundaryPoints}</div>
                    </div>
                `;
            }
        }
        
        function handle2DClick(event) {
            const rect = canvas2d.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            const R = state.radiusR;
            const centerX = canvas2d.width / 2;
            const centerY = canvas2d.height / 2;
            const scale = Math.min(canvas2d.width, canvas2d.height) / (R * 2 + 2);
            
            // Convert to lattice coordinates
            const latticeX = Math.round((x - centerX) / scale);
            const latticeY = Math.round((y - centerY) / scale);
            const distance = Math.sqrt(latticeX*latticeX + latticeY*latticeY);
            
            if (distance <= R) {
                state.currentPoint = {x: latticeX, y: latticeY};
                
                // Show point details
                const detailsDiv = document.getElementById('pointDetails');
                const analysisDiv = document.getElementById('selectedPointAnalysis');
                
                if (detailsDiv) {
                    const g = gcd(Math.abs(latticeX), Math.abs(latticeY));
                    const mu = mobius(g);
                    const isPrimitive = g === 1;
                    
                    detailsDiv.innerHTML = `
                        <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                            <h4>Point Coordinates: (${latticeX}, ${latticeY})</h4>
                            <p>Distance from origin: ${distance.toFixed(2)}</p>
                            <p>GCD: ${g} ${isPrimitive ? '(Primitive)' : '(Non-primitive)'}</p>
                            <p>Möbius μ(${g}): ${mu}</p>
                            <p>Within radius: ${distance <= R ? 'Yes' : 'No'}</p>
                        </div>
                    `;
                }
                
                if (analysisDiv) {
                    // Analyze this point's contribution
                    analysisDiv.innerHTML = `
                        <div style="background: #e8f4fd; padding: 15px; border-radius: 8px;">
                            <h4>Point Analysis</h4>
                            <p>This point contributes to the count of ${isPrimitive ? 'primitive' : 'non-primitive'} points.</p>
                            <p>Möbius weight: ${mu}</p>
                            <p>Inverse Möbius contribution: ${mu !== 0 ? 'Non-zero' : 'Zero (square factor)'}</p>
                        </div>
                    `;
                }
            }
        }
        
        // ===== 3D VISUALIZATION =====
        function init3DVisualization() {
            const container = document.getElementById('canvas3d-container');
            if (!container) return;
            
            // Create scene
            state.threeScene = new THREE.Scene();
            state.threeScene.background = new THREE.Color(0xf8f9fa);
            
            // Create camera
            state.threeCamera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / 500,
                0.1,
                1000
            );
            state.threeCamera.position.z = state.radiusR * 1.5;
            
            // Create renderer
            state.threeRenderer = new THREE.WebGLRenderer({ antialias: true });
            state.threeRenderer.setSize(container.clientWidth, 500);
            container.appendChild(state.threeRenderer.domElement);
            
            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            state.threeScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            state.threeScene.add(directionalLight);
            
            // Add axes
            const axesHelper = new THREE.AxesHelper(state.radiusR * 1.2);
            state.threeScene.add(axesHelper);
            
            draw3DLattice();
            animate3D();
            window.threeInitialized = true;
        }
        
        function draw3DLattice() {
            // Clear previous objects
            state.threeObjects.forEach(obj => state.threeScene.remove(obj));
            state.threeObjects = [];
            
            const R = state.radiusR;
            const pointSize = parseFloat(document.getElementById('pointSize3d').value);
            const showAxes = document.getElementById('showAxes').checked;
            
            // Update axes visibility
            const axes = state.threeScene.getObjectByProperty('type', 'AxesHelper');
            if (axes) axes.visible = showAxes;
            
            // Create materials
            const primitiveMat = new THREE.MeshBasicMaterial({ color: 0x3498db });
            const nonPrimitiveMat = new THREE.MeshBasicMaterial({ color: 0xe74c3c });
            const boundaryMat = new THREE.MeshBasicMaterial({ color: 0x27ae60 });
            
            let totalPoints = 0;
            let primitivePoints = 0;
            
            // Create points (sampled for performance)
            const sampling = Math.max(1, Math.floor(50 / R));
            
            for (let x = -R; x <= R; x += sampling) {
                for (let y = -R; y <= R; y += sampling) {
                    for (let z = -R; z <= R; z += sampling) {
                        const distance = Math.sqrt(x*x + y*y + z*z);
                        if (distance <= R) {
                            totalPoints++;
                            
                            const isPrimitive = gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]) === 1;
                            const isBoundary = Math.abs(distance - R) < 1.5;
                            
                            if (isPrimitive) primitivePoints++;
                            
                            // Choose material
                            const material = isBoundary ? boundaryMat : 
                                           (isPrimitive ? primitiveMat : nonPrimitiveMat);
                            
                            // Create sphere
                            const geometry = new THREE.SphereGeometry(pointSize, 8, 8);
                            const sphere = new THREE.Mesh(geometry, material);
                            sphere.position.set(x, y, z);
                            
                            state.threeScene.add(sphere);
                            state.threeObjects.push(sphere);
                        }
                    }
                }
            }
            
            // Update statistics
            const stats3d = document.getElementById('stats3d');
            if (stats3d) {
                const volume = (4/3) * Math.PI * Math.pow(R, 3);
                const density = totalPoints / volume;
                
                stats3d.innerHTML = `
                    <div class="stat-card">
                        <div class="stat-label">Total Points (3D)</div>
                        <div class="stat-value">${totalPoints}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Primitive Points</div>
                        <div class="stat-value">${primitivePoints}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Volume</div>
                        <div class="stat-value">${volume.toFixed(1)}</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Point Density</div>
                        <div class="stat-value">${density.toFixed(3)}</div>
                    </div>
                `;
            }
        }
        
        function animate3D() {
            requestAnimationFrame(animate3D);
            
            // Auto rotation
            if (document.getElementById('autoRotate').checked) {
                const speed = parseFloat(document.getElementById('rotationSpeed').value);
                state.threeScene.rotation.y += 0.01 * speed;
                state.threeScene.rotation.x += 0.005 * speed;
            }
            
            state.threeRenderer.render(state.threeScene, state.threeCamera);
        }
        
        // ===== CHART INITIALIZATION =====
        function initChart() {
            const ctx = document.getElementById('errorChart').getContext('2d');
            
            state.chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Absolute Error',
                        data: [],
                        borderColor: '#3498db',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        borderWidth: 2,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Error Analysis Over Different Radii'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Radius (R)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Error'
                            }
                        }
                    }
                }
            });
            
            updateChartData();
            window.chartInitialized = true;
        }
        
        function updateChartData() {
            if (!state.chart) return;
            
            // Generate data for different radii
            const k = state.dimensionK;
            const s = state.zetaS;
            const radii = [];
            const errors = [];
            
            for (let r = 10; r <= 100; r += 10) {
                const theoretical = computeVolume(k, r) / computeZeta(s);
                const actual = countActualPrimitivePoints(k, r);
                const error = Math.abs(theoretical - actual);
                
                radii.push(r);
                errors.push(error);
            }
            
            state.chart.data.labels = radii;
            state.chart.data.datasets[0].data = errors;
            state.chart.update();
            
            // Update systematic data table
            updateSystematicDataTable();
        }
        
        function updateSystematicDataTable() {
            const tableBody = document.getElementById('dataTableBody');
            if (!tableBody) return;
            
            const k = state.dimensionK;
            const s = state.zetaS;
            let html = '';
            
            // Generate systematic data
            for (let r = 10; r <= 100; r += 10) {
                const volume = computeVolume(k, r);
                const theoretical = Math.round(volume / computeZeta(s));
                const actual = countActualPrimitivePoints(k, r);
                const error = Math.abs(theoretical - actual);
                const errorPercent = (error / theoretical * 100).toFixed(2);
                
                // Count boundary points (approximation)
                const boundaryPoints = Math.round(2 * Math.PI * r); // Approximation
                
                html += `
                    <tr>
                        <td>${r}</td>
                        <td>${Math.round(volume)}</td>
                        <td>${actual}</td>
                        <td>${theoretical}</td>
                        <td>${error.toFixed(1)}</td>
                        <td>${errorPercent}%</td>
                        <td>${boundaryPoints}</td>
                    </tr>
                `;
            }
            
            tableBody.innerHTML = html;
        }
        
        // ===== EXPORT FUNCTIONS =====
        function export2D(format) {
            if (!canvas2d) return;
            
            const link = document.createElement('a');
            
            if (format === 'svg') {
                // Create SVG from canvas
                const svgData = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="${canvas2d.width}" height="${canvas2d.height}">
                        <foreignObject width="100%" height="100%">
                            <div xmlns="http://www.w3.org/1999/xhtml">
                                <img src="${canvas2d.toDataURL('image/png')}" width="${canvas2d.width}" height="${canvas2d.height}"/>
                            </div>
                        </foreignObject>
                    </svg>
                `;
                
                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                link.href = URL.createObjectURL(blob);
                link.download = `lattice-2d-${Date.now()}.svg`;
            } else {
                // PNG export
                link.href = canvas2d.toDataURL('image/png');
                link.download = `lattice-2d-${Date.now()}.png`;
            }
            
            link.click();
            alert(`2D visualization exported as ${format.toUpperCase()}!`);
        }
        
        function export2DData() {
            const R = state.radiusR;
            let csv = 'x,y,gcd,is_primitive,distance\n';
            
            for (let x = -R; x <= R; x++) {
                for (let y = -R; y <= R; y++) {
                    const distance = Math.sqrt(x*x + y*y);
                    if (distance <= R) {
                        const g = gcd(Math.abs(x), Math.abs(y));
                        csv += `${x},${y},${g},${g === 1 ? 'true' : 'false'},${distance.toFixed(2)}\n`;
                    }
                }
            }
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `lattice-data-${Date.now()}.csv`;
            link.click();
            alert('2D data exported as CSV!');
        }
        
        function export3D(format) {
            if (!state.threeRenderer) return;
            
            const link = document.createElement('a');
            const dataURL = state.threeRenderer.domElement.toDataURL('image/png');
            
            link.href = dataURL;
            link.download = `lattice-3d-${Date.now()}.png`;
            link.click();
            alert('3D visualization exported as PNG!');
        }
        
        function capture3DView() {
            if (!state.threeRenderer) return;
            
            // Capture current view
            const dataURL = state.threeRenderer.domElement.toDataURL('image/png');
            
            // Show preview
            const preview = window.open();
            preview.document.write(`
                <html>
                    <body style="margin: 0; padding: 20px; background: #f8f9fa;">
                        <h2>3D View Capture</h2>
                        <img src="${dataURL}" style="max-width: 90%; border: 1px solid #ddd;">
                        <p style="margin-top: 20px;">
                            <button onclick="window.location.href='${dataURL}'" 
                                    style="padding: 10px 20px; background: #3498db; color: white; border: none; cursor: pointer;">
                                Download Image
                            </button>
                        </p>
                    </body>
                </html>
            `);
        }
        
        function exportChart(format) {
            if (!state.chart) return;
            
            const link = document.createElement('a');
            link.href = state.chart.toBase64Image();
            link.download = `error-chart-${Date.now()}.png`;
            link.click();
            alert('Chart exported as PNG!');
        }
        
        function exportAllData() {
            const data = {
                parameters: {
                    zetaS: state.zetaS,
                    radiusR: state.radiusR,
                    dimensionK: state.dimensionK,
                    timestamp: new Date().toISOString()
                },
                calculations: {
                    volume: computeVolume(state.dimensionK, state.radiusR),
                    zetaValue: computeZeta(state.zetaS),
                    theoretical: computeVolume(state.dimensionK, state.radiusR) / computeZeta(state.zetaS),
                    actual: countActualPrimitivePoints(state.dimensionK, state.radiusR)
                },
                systematicData: []
            };
            
            // Add systematic data
            for (let r = 10; r <= 100; r += 10) {
                data.systematicData.push({
                    radius: r,
                    volume: computeVolume(state.dimensionK, r),
                    actual: countActualPrimitivePoints(state.dimensionK, r),
                    theoretical: computeVolume(state.dimensionK, r) / computeZeta(state.zetaS)
                });
            }
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `math-data-${Date.now()}.json`;
            link.click();
            alert('All data exported as JSON!');
        }
        
        function exportAnalysisReport() {
            // Create a simple HTML report
            const report = `
                <html>
                <head>
                    <title>Mathematical Analysis Report</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        h1 { color: #2c3e50; }
                        .section { margin: 20px 0; padding: 20px; border: 1px solid #ddd; }
                        .stat { display: inline-block; margin: 10px; padding: 10px; background: #f8f9fa; }
                    </style>
                </head>
                <body>
                    <h1>Mathematical Analysis Report</h1>
                    <p>Generated: ${new Date().toLocaleString()}</p>
                    
                    <div class="section">
                        <h2>Parameters</h2>
                        <p>Zeta(s): s = ${state.zetaS}</p>
                        <p>Radius: R = ${state.radiusR}</p>
                        <p>Dimension: k = ${state.dimensionK}</p>
                    </div>
                    
                    <div class="section">
                        <h2>Results</h2>
                        <div class="stat">Volume: ${computeVolume(state.dimensionK, state.radiusR).toFixed(2)}</div>
                        <div class="stat">ζ(${state.zetaS}): ${computeZeta(state.zetaS).toFixed(6)}</div>
                        <div class="stat">Theoretical N: ${Math.round(computeVolume(state.dimensionK, state.radiusR) / computeZeta(state.zetaS))}</div>
                        <div class="stat">Actual N: ${countActualPrimitivePoints(state.dimensionK, state.radiusR)}</div>
                    </div>
                </body>
                </html>
            `;
            
            const blob = new Blob([report], { type: 'text/html' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `analysis-report-${Date.now()}.html`;
            link.click();
            alert('Analysis report exported as HTML!');
        }
        
        function batchExport() {
            // Export everything
            export2D('png');
            setTimeout(() => export3D('png'), 500);
            setTimeout(() => exportChart('png'), 1000);
            setTimeout(() => exportAllData(), 1500);
            
            alert('Batch export started! Multiple files will download.');
        }
        
        // ===== UPDATE ALL VISUALIZATIONS =====
        function updateAllVisualizations() {
            // Update theory explorer
            updateTheoryExplorer();
            
            // Update 2D visualization
            if (window.canvas2dInitialized) {
                draw2DLattice();
            }
            
            // Update 3D visualization
            if (window.threeInitialized) {
                // Update camera position based on radius
                state.threeCamera.position.z = state.radiusR * 1.5;
                draw3DLattice();
            }
            
            // Update chart
            if (window.chartInitialized) {
                updateChartData();
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            if (window.canvas2dInitialized && canvas2d) {
                canvas2d.width = canvas2d.clientWidth;
                draw2DLattice();
            }
            
            if (window.threeInitialized && state.threeRenderer) {
                const container = document.getElementById('canvas3d-container');
                state.threeCamera.aspect = container.clientWidth / 500;
                state.threeCamera.updateProjectionMatrix();
                state.threeRenderer.setSize(container.clientWidth, 500);
            }
        });
    </script>
</body>
</html>
