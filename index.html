
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematical Discovery Platform</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg: #fff; --bg2: #f8f9fa; --bg3: #e9ecef; --text: #212529; --text2: #495057;
            --border: #dee2e6; --blue: #0066cc; --purple: #6f42c1; --green: #28a745; --red: #dc3545;
            --yellow: #ffc107; --orange: #fd7e14;
        }
        body.dark { --bg: #1a1a1a; --bg2: #2d2d2d; --bg3: #3a3a3a; --text: #e0e0e0; --text2: #b0b0b0; --border: #4a4a4a; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui; background: var(--bg); color: var(--text); line-height: 1.6; transition: background 0.3s, color 0.3s; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; padding: 40px 20px; background: linear-gradient(135deg, var(--blue), var(--purple));
            color: white; border-radius: 12px; margin-bottom: 30px; position: relative; overflow: hidden; }
        .header::before { content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%); animation: pulse 4s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; position: relative; z-index: 1; }
        .header p { position: relative; z-index: 1; }
        .tabs { display: flex; gap: 5px; margin-bottom: 30px; background: var(--bg2); padding: 10px; border-radius: 12px; flex-wrap: wrap; }
        .tab-btn { flex: 1; min-width: 120px; padding: 12px 20px; border: none; background: var(--bg3); color: var(--text);
            cursor: pointer; border-radius: 8px; font-weight: 600; transition: all 0.3s; }
        .tab-btn:hover { background: var(--blue); color: white; transform: translateY(-2px); }
        .tab-btn.active { background: var(--blue); color: white; box-shadow: 0 4px 12px rgba(0,102,204,0.3); }
        .panel { display: none; animation: fadeIn 0.5s; }
        .panel.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .section { background: var(--bg2); padding: 30px; border-radius: 12px; margin-bottom: 30px; transition: all 0.3s; }
        .section:hover { box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        .section h2 { color: var(--blue); margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .help-icon { display: inline-block; width: 20px; height: 20px; background: var(--blue); color: white;
            border-radius: 50%; text-align: center; line-height: 20px; font-size: 12px; cursor: help; }
        .tooltip { position: relative; }
        .tooltip:hover::after { content: attr(data-tip); position: absolute; bottom: 125%; left: 50%;
            transform: translateX(-50%); padding: 8px 12px; background: var(--text); color: var(--bg);
            border-radius: 6px; white-space: nowrap; z-index: 1000; font-size: 12px; }
        .controls { margin: 20px 0; padding: 20px; background: var(--bg3); border-radius: 8px; }
        .controls label { display: block; margin: 10px 0; font-weight: 600; }
        .controls input[type="range"] { width: 100%; }
        .controls button { padding: 10px 20px; background: var(--blue); color: white; border: none;
            border-radius: 6px; cursor: pointer; margin: 5px; transition: all 0.3s; }
        .controls button:hover { background: var(--purple); transform: scale(1.05); }
        .controls button:disabled { background: var(--text2); cursor: not-allowed; transform: none; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat { background: var(--bg3); padding: 20px; border-radius: 8px; text-align: center; transition: all 0.3s; }
        .stat:hover { transform: translateY(-5px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .stat .val { font-size: 2rem; font-weight: bold; color: var(--blue); transition: all 0.5s; }
        .stat .lbl { font-size: 0.9rem; color: var(--text2); }
        canvas { border: 2px solid var(--border); border-radius: 8px; display: block; margin: 20px auto; max-width: 100%; }
        #canvas3d { width: 100%; height: 600px; cursor: grab; }
        #canvas3d:active { cursor: grabbing; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; overflow-x: auto; display: block; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg3); color: var(--blue); font-weight: 600; position: sticky; top: 0; }
        .btn-fixed { position: fixed; bottom: 20px; padding: 12px 24px; border: none; border-radius: 25px;
            cursor: pointer; font-weight: 600; z-index: 1000; color: white; transition: all 0.3s; }
        .btn-fixed:hover { transform: translateY(-3px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        #darkBtn { right: 20px; background: var(--blue); }
        #helpBtn { right: 140px; background: var(--green); }
        .formula { background: var(--bg3); padding: 20px; border-left: 4px solid var(--blue); border-radius: 8px; margin: 20px 0; }
        .warning { background: #fff3cd; color: #856404; padding: 15px; border-left: 4px solid var(--yellow); border-radius: 8px; margin: 20px 0; }
        body.dark .warning { background: #3d3106; color: #ffc107; }
        .loading { display: none; text-align: center; padding: 20px; }
        .loading.active { display: block; }
        .spinner { border: 4px solid var(--border); border-top: 4px solid var(--blue); border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .compare-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .compare-item { background: var(--bg3); padding: 15px; border-radius: 8px; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7);
            z-index: 2000; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { background: var(--bg); padding: 30px; border-radius: 12px; max-width: 600px; max-height: 80vh;
            overflow-y: auto; position: relative; }
        .modal-close { position: absolute; top: 10px; right: 10px; font-size: 24px; cursor: pointer; color: var(--text2); }
        .export-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
        .data-table-container { max-height: 400px; overflow-y: auto; }
        @media (max-width: 768px) {
            .header h1 { font-size: 1.8rem; }
            .tabs { flex-direction: column; }
            .tab-btn { min-width: 100%; }
            #canvas3d { height: 400px; }
            .btn-fixed { padding: 10px 16px; font-size: 14px; }
            #helpBtn { right: 20px; bottom: 70px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Mathematical Discovery Platform</h1>
            <p>Primitive Lattice Points & Boundary Cancellation</p>
            <p style="margin-top:10px; font-size:0.9rem">By Wessen Getachew | <a href="https://twitter.com/7dview" style="color:white">@7dview</a></p>
        </header>

        <nav class="tabs">
            <button class="tab-btn active" onclick="showTab('theory')">Theory</button>
            <button class="tab-btn" onclick="showTab('applications')">Applications</button>
            <button class="tab-btn" onclick="showTab('viz2d')">2D Viz</button>
            <button class="tab-btn" onclick="showTab('viz3d')">3D Viz</button>
            <button class="tab-btn" onclick="showTab('comparison')">Compare</button>
            <button class="tab-btn" onclick="showTab('analysis')">Analysis</button>
            <button class="tab-btn" onclick="showTab('tools')">Tools</button>
            <button class="tab-btn" onclick="showTab('derivation')">Derivation</button>
        </nav>

        <div id="theory" class="panel active">
            <div class="section">
                <h2>Abstract <span class="help-icon tooltip" data-tip="Core theoretical framework">?</span></h2>
                <p>We present a framework for counting primitive lattice points in k-dimensional spheres. Points (x₁, x₂, ..., xₖ) with gcd(x₁, x₂, ..., xₖ) = 1 follow the asymptotic formula:</p>
                <div class="formula">$$N_k(R) = \frac{V_k R^k}{\zeta(k)} + O(R^{k-1})$$</div>
                <p style="margin-top:15px">Where V_k is the volume of the unit k-sphere and ζ(k) is the Riemann zeta function. The density of primitive points approaches 1/ζ(k) as R → ∞.</p>
            </div>
            
            <div class="section">
                <h2>Boundary Cancellation Principle</h2>
                <p>The key insight is that non-primitive points (those sharing a common factor d > 1) can be expressed as d·(primitive point). Through Möbius inversion, we show that boundary contributions from non-primitive points cancel systematically, leaving only the volume term divided by ζ(k).</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) \cdot |\{(x_1,...,x_k) : \sum x_i^2 \leq (R/d)^2\}|$$</div>
                <p style="margin-top:15px">The Möbius function μ(d) = (-1)^ω(d) for square-free d (where ω counts distinct prime factors) ensures alternating cancellation of boundary terms.</p>
            </div>

            <div class="section">
                <h2>Interactive Explorer <span class="help-icon tooltip" data-tip="Adjust parameters to see predictions">?</span></h2>
                <div class="controls">
                    <label>Dimension k: <span id="tk">3</span></label>
                    <input type="range" id="tks" min="2" max="12" value="3" oninput="updateTheory()">
                    <label>Radius R: <span id="tr">50</span></label>
                    <input type="range" id="trs" min="10" max="200" value="50" step="10" oninput="updateTheory()">
                    <button onclick="exportTheoryData()">Export Data</button>
                </div>
                <div class="stats">
                    <div class="stat"><div class="val" id="sz">1.202</div><div class="lbl">ζ(k)</div></div>
                    <div class="stat"><div class="val" id="sp">4186</div><div class="lbl">Predicted N_k(R)</div></div>
                    <div class="stat"><div class="val" id="sd">0.832</div><div class="lbl">Density (1/ζ(k))</div></div>
                    <div class="stat"><div class="val" id="svol">523.6</div><div class="lbl">Sphere Volume</div></div>
                </div>
                <div class="data-table-container">
                    <table><thead><tr><th>k</th><th>ζ(k)</th><th>1/ζ(k)</th><th>V_k (unit sphere)</th></tr></thead><tbody id="tbl"></tbody></table>
                </div>
            </div>
        </div>

        <div id="applications" class="panel">
            <div class="section">
                <h2>Real-World Applications</h2>
                <h3>1. Cryptography & Number Theory</h3>
                <p>Primitive lattice points correspond to coprime integers, essential for:</p>
                <ul style="margin-left: 25px; margin-top: 10px;">
                    <li><b>RSA Key Generation:</b> Finding large coprime numbers for secure encryption</li>
                    <li><b>Lattice-Based Cryptography:</b> Post-quantum security relies on hard lattice problems</li>
                    <li><b>Random Number Generation:</b> Coprime sequences provide high-quality randomness</li>
                </ul>

                <h3 style="margin-top: 25px;">2. Physics & Crystallography</h3>
                <p>Lattice structures appear throughout nature:</p>
                <ul style="margin-left: 25px; margin-top: 10px;">
                    <li><b>Crystal Structures:</b> Atoms arrange in primitive lattice configurations</li>
                    <li><b>X-ray Diffraction:</b> Scattering patterns reveal lattice spacing</li>
                    <li><b>Quantum Mechanics:</b> Particle states in periodic potentials</li>
                </ul>

                <h3 style="margin-top: 25px;">3. Computer Graphics & Gaming</h3>
                <ul style="margin-left: 25px; margin-top: 10px;">
                    <li><b>Procedural Generation:</b> Creating diverse, non-repeating patterns</li>
                    <li><b>Collision Detection:</b> Efficient spatial partitioning using lattice grids</li>
                    <li><b>Texture Synthesis:</b> Generating natural-looking patterns</li>
                </ul>

                <h3 style="margin-top: 25px;">4. Data Science & Optimization</h3>
                <ul style="margin-left: 25px; margin-top: 10px;">
                    <li><b>Sampling Theory:</b> Optimal point distributions for numerical integration</li>
                    <li><b>Sphere Packing:</b> Information theory and error-correcting codes</li>
                    <li><b>High-Dimensional Statistics:</b> Understanding point distributions in many dimensions</li>
                </ul>
            </div>
        </div>

        <div id="viz2d" class="panel">
            <div class="section">
                <h2>2D Lattice Visualization <span class="help-icon tooltip" data-tip="Blue=primitive, Red=non-primitive">?</span></h2>
                <div class="controls">
                    <label>Radius: <span id="r2v">50</span></label>
                    <input type="range" id="r2" min="10" max="150" value="50" step="5" oninput="draw2D()">
                    <label>Point Size: <span id="psv">3</span></label>
                    <input type="range" id="ps" min="1" max="10" value="3" oninput="draw2D()">
                    <button onclick="exportCanvas('c2d', '2d-lattice')">Export Image</button>
                    <button onclick="exportPointData2D()">Export Points</button>
                </div>
                <div class="warning" id="warn2d" style="display:none;">
                    ⚠️ Large radius values may slow performance. Consider using R ≤ 100.
                </div>
                <div class="loading" id="load2d"><div class="spinner"></div><p>Computing lattice points...</p></div>
                <canvas id="c2d" width="800" height="800"></canvas>
                <div class="stats">
                    <div class="stat"><div class="val" id="p2">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t2">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d2">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e2">0</div><div class="lbl">|Predicted - Actual|</div></div>
                </div>
            </div>
        </div>

        <div id="viz3d" class="panel">
            <div class="section">
                <h2>3D Lattice Visualization <span class="help-icon tooltip" data-tip="Click and drag to rotate">?</span></h2>
                <div class="controls">
                    <label>Radius: <span id="r3v">25</span></label>
                    <input type="range" id="r3" min="5" max="40" value="25" step="5" oninput="draw3D()">
                    <button onclick="reset3D()">Reset View</button>
                    <button onclick="toggleRotation()">Auto-Rotate</button>
                    <button onclick="export3DData()">Export Points</button>
                </div>
                <div class="warning" id="warn3d" style="display:none;">
                    ⚠️ Radius > 30 generates many points and may impact performance.
                </div>
                <div class="loading" id="load3d"><div class="spinner"></div><p>Generating 3D lattice...</p></div>
                <div id="c3d"></div>
                <div class="stats">
                    <div class="stat"><div class="val" id="p3">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t3">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d3">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e3">0</div><div class="lbl">Error</div></div>
                </div>
            </div>
        </div>

        <div id="comparison" class="panel">
            <div class="section">
                <h2>Dimension Comparison <span class="help-icon tooltip" data-tip="Compare different dimensions">?</span></h2>
                <div class="controls">
                    <label>Fixed Radius: <span id="crv">30</span></label>
                    <input type="range" id="cr" min="10" max="50" value="30" step="5" oninput="updateComparison()">
                    <button onclick="exportComparisonData()">Export Comparison</button>
                </div>
                <div class="compare-grid" id="compGrid"></div>
            </div>
        </div>

        <div id="analysis" class="panel">
            <div class="section">
                <h2>Error Analysis <span class="help-icon tooltip" data-tip="Study O(R^(k-1)) error term">?</span></h2>
                <div class="controls">
                    <label>Dimension k: <span id="akv">2</span></label>
                    <input type="range" id="ak" min="2" max="4" value="2" oninput="document.getElementById('akv').textContent=this.value">
                    <label>Max Radius: <span id="mrv">100</span></label>
                    <input type="range" id="mr" min="20" max="200" value="100" step="10" oninput="document.getElementById('mrv').textContent=this.value">
                    <button onclick="runAnalysis()">Compute Analysis</button>
                    <button onclick="exportChartData()">Export Chart Data</button>
                </div>
                <div class="loading" id="loadAnalysis"><div class="spinner"></div><p>Computing error analysis...</p></div>
                <canvas id="ch" width="800" height="400"></canvas>
                <div class="formula" style="margin-top: 20px;">
                    <p><b>Error Bound Theory:</b></p>
                    <p>The error term O(R^(k-1)) arises from boundary effects. For k=2, the error is O(R), corresponding to points near the circle boundary. As k increases, the error term becomes relatively smaller compared to the main term R^k.</p>
                </div>
            </div>
        </div>

        <div id="tools" class="panel">
            <div class="section">
                <h2>Mathematical Tools <span class="help-icon tooltip" data-tip="Number theory utilities">?</span></h2>
                
                <h3>GCD Calculator</h3>
                <div class="controls">
                    <input type="text" id="gi" placeholder="12, 18, 24" style="width:100%; padding:10px">
                    <button onclick="calcGCD()">Calculate</button>
                    <div id="gr" style="margin-top:15px"></div>
                </div>

                <h3>Möbius Function μ(n)</h3>
                <div class="controls">
                    <input type="number" id="mi" placeholder="30" style="width:100%; padding:10px" min="1">
                    <button onclick="calcMobius()">Calculate</button>
                    <div id="mr2" style="margin-top:15px"></div>
                </div>

                <h3>Prime Factorization</h3>
                <div class="controls">
                    <input type="number" id="pi" placeholder="360" style="width:100%; padding:10px" min="2">
                    <button onclick="calcPrime()">Factorize</button>
                    <div id="pr" style="margin-top:15px"></div>
                </div>

                <h3>Coprimality Checker</h3>
                <div class="controls">
                    <input type="text" id="cci" placeholder="15, 28" style="width:100%; padding:10px">
                    <button onclick="checkCoprime()">Check</button>
                    <div id="ccr" style="margin-top:15px"></div>
                </div>

                <h3>Point Search</h3>
                <div class="controls">
                    <input type="text" id="psi" placeholder="3, 4 (finds if primitive)" style="width:100%; padding:10px">
                    <button onclick="searchPoint()">Search</button>
                    <div id="psr" style="margin-top:15px"></div>
                </div>
            </div>
        </div>

        <div id="derivation" class="panel">
            <div class="section">
                <h2>Interactive Derivation</h2>
                
                <h3>Step 1: Counting Lattice Points</h3>
                <p>Start with all lattice points in a k-dimensional sphere of radius R:</p>
                <div class="formula">$$L_k(R) = |\{(x_1,...,x_k) \in \mathbb{Z}^k : x_1^2 + ... + x_k^2 \leq R^2\}|$$</div>
                <p>Asymptotically, this equals the volume: L_k(R) ~ V_k R^k</p>

                <h3>Step 2: Separating by GCD</h3>
                <p>Partition points by their greatest common divisor d:</p>
                <div class="formula">$$L_k(R) = \sum_{d=1}^{R} N_k(R/d)$$</div>
                <p>Where N_k(R/d) counts primitive points in a sphere of radius R/d.</p>

                <h3>Step 3: Möbius Inversion</h3>
                <p>Inverting the previous relation using Möbius function:</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) L_k(R/d)$$</div>
                
                <h3>Step 4: Asymptotic Expansion</h3>
                <p>Substituting L_k(R/d) ~ V_k (R/d)^k:</p>
                <div class="formula">$$N_k(R) = V_k R^k \sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} + O(R^{k-1})$$</div>

                <h3>Step 5: Zeta Connection</h3>
                <p>The sum equals the reciprocal of the zeta function:</p>
                <div class="formula">$$\sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} = \frac{1}{\zeta(k)}$$</div>
                
                <h3>Final Result</h3>
                <div class="formula">$$N_k(R) = \frac{V_k R^k}{\zeta(k)} + O(R^{k-1})$$</div>
                <p>This elegant formula connects geometry (V_k), analysis (ζ(k)), and number theory (primitive points)!</p>
                
                <div class="controls" style="margin-top: 30px;">
                    <button onclick="showDerivationAnimation()">Animate Derivation</button>
                </div>
            </div>
        </div>
    </div>

    <button class="btn-fixed" id="helpBtn" onclick="showHelp()">Help</button>
    <button class="btn-fixed" id="darkBtn" onclick="toggleDark()">Dark Mode</button>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeHelp()">&times;</span>
            <h2>Platform Guide</h2>
            <h3>Navigation</h3>
            <p>Use the tabs to explore different aspects of primitive lattice points.</p>
            <h3>2D/3D Visualizations</h3>
            <p><b>Blue points:</b> Primitive (coprime coordinates)<br><b>Red points:</b> Non-primitive (share common factor)</p>
            <p>In 3D, click and drag to rotate the view.</p>
            <h3>Performance Tips</h3>
            <p>• Keep radius ≤ 100 in 2D, ≤ 30 in 3D for smooth performance<br>• Use Export buttons to save data and images<br>• Compare mode shows multiple dimensions simultaneously</p>
            <h3>Tools Section</h3>
            <p>Calculate GCD, Möbius function, prime factorizations, and search for specific lattice points.</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, chart, autoRotate = false;
        const cache = { mobius: new Map(), gcd: new Map(), points2D: null, points3D: null };
        let mouseDown = false, prevMouse = { x: 0, y: 0 };

        function gcd(a, b) {
            a = Math.abs(a); b = Math.abs(b);
            while (b) [a, b] = [b, a % b];
            return a;
        }

        function gcdArray(arr) { return arr.reduce((a, b) => gcd(a, b)); }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2)
                if (n % i === 0) return false;
            return true;
        }

        function primeFactors(n) {
            const f = []; let d = 2;
            while (n > 1) {
                while (n % d === 0) { f.push(d); n /= d; }
                d++; if (d * d > n && n > 1) { f.push(n); break; }
            }
            return f;
        }

        function mobius(n) {
            if (cache.mobius.has(n)) return cache.mobius.get(n);
            if (n === 1) return 1;
            const f = primeFactors(n), u = [...new Set(f)];
            const r = f.length !== u.length ? 0 : Math.pow(-1, f.length);
            cache.mobius.set(n, r);
            return r;
        }

        function zeta(k) {
            const z = { 2: Math.PI**2/6, 3: 1.2020569, 4: Math.PI**4/90, 5: 1.0369278, 6: Math.PI**6/945, 
                       7: 1.0083493, 8: Math.PI**8/9450, 9: 1.00200839, 10: 1.00099457, 11: 1.00049419, 12: 1.00024608 };
            return z[k] || 1 + 2**-k;
        }

        function sphereVolume(k, R) {
            const gamma = k % 2 === 0 ? 
                Math.PI**(k/2) / factorial(k/2) : 
                2 * factorial((k-1)/2) * Math.PI**((k-1)/2) / factorial(k);
            return gamma * R**k;
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let res = 1;
            for (let i = 2; i <= n; i++) res *= i;
            return res;
        }

        function animateValue(id, start, end, duration = 500) {
            const el = document.getElementById(id);
            const range = end - start;
            const increment = range / (duration / 16);
            let current = start;
            const timer = setInterval(() => {
                current += increment;
                if ((increment > 0 && current >= end) || (increment < 0 && current <= end)) {
                    el.textContent = typeof end === 'number' && end % 1 !== 0 ? end.toFixed(3) : Math.round(end).toLocaleString();
                    clearInterval(timer);
                } else {
                    el.textContent = typeof current === 'number' && current % 1 !== 0 ? current.toFixed(3) : Math.round(current).toLocaleString();
                }
            }, 16);
        }

        function showTab(id) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            event.target.classList.add('active');
            if (id === 'viz2d') draw2D();
            if (id === 'viz3d' && !scene) init3D();
            if (id === 'comparison') updateComparison();
        }

        function updateTheory() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            document.getElementById('tk').textContent = k;
            document.getElementById('tr').textContent = R;
            const z = zeta(k), d = 1/z;
            const vol = sphereVolume(k, R);
            const pred = Math.round(vol / z);
            
            animateValue('sz', parseFloat(document.getElementById('sz').textContent) || z, z);
            animateValue('sd', parseFloat(document.getElementById('sd').textContent) || d, d);
            animateValue('sp', parseInt(document.getElementById('sp').textContent.replace(/,/g, '')) || pred, pred);
            animateValue('svol', parseFloat(document.getElementById('svol').textContent) || vol, vol);
        }

        function draw2D() {
            const canvas = document.getElementById('c2d'), ctx = canvas.getContext('2d');
            const R = parseInt(document.getElementById('r2').value);
            const sz = parseInt(document.getElementById('ps').value);
            document.getElementById('r2v').textContent = R;
            document.getElementById('psv').textContent = sz;
            
            document.getElementById('warn2d').style.display = R > 100 ? 'block' : 'none';
            if (R > 120) {
                document.getElementById('load2d').classList.add('active');
            }
            
            setTimeout(() => {
                ctx.clearRect(0, 0, 800, 800);
                const cx = 400, cy = 400, sc = 350/R;
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(cx, cy, R*sc, 0, 2*Math.PI); ctx.stroke();
                
                const primPoints = [], nonPrimPoints = [];
                let prim = 0, tot = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R) {
                            tot++;
                            const p = gcd(x, y) === 1;
                            if (p) { prim++; primPoints.push({x, y}); }
                            else nonPrimPoints.push({x, y});
                        }
                    }
                }
                
                nonPrimPoints.forEach(pt => {
                    ctx.fillStyle = '#dc3545';
                    ctx.beginPath();
                    ctx.arc(cx + pt.x*sc, cy - pt.y*sc, sz, 0, 2*Math.PI);
                    ctx.fill();
                });
                
                primPoints.forEach(pt => {
                    ctx.fillStyle = '#0066cc';
                    ctx.beginPath();
                    ctx.arc(cx + pt.x*sc, cy - pt.y*sc, sz, 0, 2*Math.PI);
                    ctx.fill();
                });
                
                cache.points2D = { primitive: primPoints, nonPrimitive: nonPrimPoints, R };
                
                const pred = Math.round(Math.PI * R * R / zeta(2));
                const error = Math.abs(pred - prim);
                
                animateValue('p2', 0, prim);
                animateValue('t2', 0, tot);
                document.getElementById('d2').textContent = ((prim/tot)*100).toFixed(1) + '%';
                animateValue('e2', 0, error);
                
                document.getElementById('load2d').classList.remove('active');
            }, 100);
        }

        function init3D() {
            const c = document.getElementById('c3d');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(document.body.classList.contains('dark') ? 0x1a1a1a : 0xffffff);
            camera = new THREE.PerspectiveCamera(75, c.clientWidth/600, 0.1, 1000);
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(c.clientWidth, 600);
            c.appendChild(renderer.domElement);
            
            const light1 = new THREE.AmbientLight(0xffffff, 0.6);
            const light2 = new THREE.DirectionalLight(0xffffff, 0.4);
            light2.position.set(1, 1, 1);
            scene.add(light1, light2);
            
            const axes = new THREE.AxesHelper(35);
            scene.add(axes);
            
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', e => {
                mouseDown = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            canvas.addEventListener('mousemove', e => {
                if (mouseDown && !autoRotate) {
                    const dx = e.clientX - prevMouse.x;
                    const dy = e.clientY - prevMouse.y;
                    const rotSpeed = 0.005;
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), dx * rotSpeed);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    camera.position.applyAxisAngle(right, dy * rotSpeed);
                    camera.lookAt(0, 0, 0);
                    prevMouse = { x: e.clientX, y: e.clientY };
                }
            });
            canvas.addEventListener('mouseup', () => mouseDown = false);
            canvas.addEventListener('mouseleave', () => mouseDown = false);
            
            draw3D();
            animate3D();
        }

        function draw3D() {
            if (!scene) return;
            while(scene.children.length > 3) scene.remove(scene.children[3]);
            
            const R = parseInt(document.getElementById('r3').value);
            document.getElementById('r3v').textContent = R;
            document.getElementById('warn3d').style.display = R > 30 ? 'block' : 'none';
            
            if (R > 25) document.getElementById('load3d').classList.add('active');
            
            setTimeout(() => {
                const sg = new THREE.SphereGeometry(R, 32, 32);
                const sm = new THREE.MeshBasicMaterial({ 
                    color: 0x6f42c1, wireframe: true, transparent: true, opacity: 0.15 
                });
                scene.add(new THREE.Mesh(sg, sm));
                
                const pg = new THREE.BufferGeometry(), ng = new THREE.BufferGeometry();
                const pp = [], np = [], primPoints = [], nonPrimPoints = [];
                let prim = 0, tot = 0;
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        for (let z = -R; z <= R; z++) {
                            if (x*x + y*y + z*z <= R*R) {
                                tot++;
                                if (gcdArray([x,y,z]) === 1) { 
                                    prim++; 
                                    pp.push(x,y,z);
                                    primPoints.push({x, y, z});
                                } else {
                                    np.push(x,y,z);
                                    nonPrimPoints.push({x, y, z});
                                }
                            }
                        }
                    }
                }
                
                cache.points3D = { primitive: primPoints, nonPrimitive: nonPrimPoints, R };
                
                if (pp.length) {
                    pg.setAttribute('position', new THREE.Float32BufferAttribute(pp, 3));
                    scene.add(new THREE.Points(pg, new THREE.PointsMaterial({ color: 0x0066cc, size: 0.6 })));
                }
                if (np.length) {
                    ng.setAttribute('position', new THREE.Float32BufferAttribute(np, 3));
                    scene.add(new THREE.Points(ng, new THREE.PointsMaterial({ color: 0xdc3545, size: 0.6 })));
                }
                
                const pred = Math.round(4 * Math.PI * R**3 / (3 * zeta(3)));
                const error = Math.abs(pred - prim);
                
                animateValue('p3', 0, prim);
                animateValue('t3', 0, tot);
                document.getElementById('d3').textContent = ((prim/tot)*100).toFixed(1) + '%';
                animateValue('e3', 0, error);
                
                document.getElementById('load3d').classList.remove('active');
            }, 100);
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if (renderer && scene && camera) {
                if (autoRotate) {
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.005);
                    camera.lookAt(0, 0, 0);
                }
                renderer.render(scene, camera);
            }
        }

        function reset3D() {
            if (camera) { 
                camera.position.set(50, 50, 50); 
                camera.lookAt(0, 0, 0); 
            }
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
            event.target.textContent = autoRotate ? 'Stop Rotation' : 'Auto-Rotate';
        }

        function updateComparison() {
            const R = parseInt(document.getElementById('cr').value);
            document.getElementById('crv').textContent = R;
            const grid = document.getElementById('compGrid');
            grid.innerHTML = '';
            
            for (let k = 2; k <= 6; k++) {
                const z = zeta(k);
                const vol = sphereVolume(k, R);
                const pred = Math.round(vol / z);
                const density = (1/z * 100).toFixed(1);
                
                grid.innerHTML += `
                    <div class="compare-item">
                        <h3>Dimension k = ${k}</h3>
                        <p><b>ζ(${k}):</b> ${z.toFixed(4)}</p>
                        <p><b>Predicted Points:</b> ${pred.toLocaleString()}</p>
                        <p><b>Density:</b> ${density}%</p>
                        <p><b>Volume:</b> ${vol.toFixed(2)}</p>
                    </div>
                `;
            }
        }

        function runAnalysis() {
            const canvas = document.getElementById('ch');
            const ctx = canvas.getContext('2d');
            const mr = parseInt(document.getElementById('mr').value);
            const k = parseInt(document.getElementById('ak').value);
            
            document.getElementById('loadAnalysis').classList.add('active');
            
            setTimeout(() => {
                if (chart) chart.destroy();
                const data = [];
                
                for (let R = 10; R <= mr; R += 5) {
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / zeta(k));
                    let act = 0;
                    
                    if (k === 2) {
                        for (let x = -R; x <= R; x++)
                            for (let y = -R; y <= R; y++)
                                if (x*x + y*y <= R*R && gcd(x,y) === 1) act++;
                    } else if (k === 3 && R <= 30) {
                        for (let x = -R; x <= R; x++)
                            for (let y = -R; y <= R; y++)
                                for (let z = -R; z <= R; z++)
                                    if (x*x + y*y + z*z <= R*R && gcdArray([x,y,z]) === 1) act++;
                    } else {
                        act = pred;
                    }
                    
                    data.push({ x: R, y: Math.abs(pred - act) });
                }
                
                chart = new Chart(ctx, {
                    type: 'line',
                    data: { 
                        datasets: [{ 
                            label: `Error (k=${k})`, 
                            data, 
                            borderColor: '#0066cc', 
                            backgroundColor: 'rgba(0,102,204,0.1)',
                            tension: 0.1,
                            fill: true
                        }] 
                    },
                    options: { 
                        responsive: true,
                        scales: { 
                            y: { beginAtZero: true, title: { display: true, text: '|Predicted - Actual|' } },
                            x: { title: { display: true, text: 'Radius R' } }
                        },
                        plugins: {
                            legend: { display: true },
                            tooltip: { mode: 'index', intersect: false }
                        }
                    }
                });
                
                document.getElementById('loadAnalysis').classList.remove('active');
            }, 100);
        }

        function calcGCD() {
            const inp = document.getElementById('gi').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('gr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1 ? '<span style="color:var(--green)">✓ Coprime</span>' : '<span style="color:var(--red)">✗ Not Coprime</span>';
            document.getElementById('gr').innerHTML = `<p><b>Numbers:</b> ${nums.join(', ')}</p><p><b>GCD:</b> ${g}</p><p>${coprime}</p>`;
        }

        function calcMobius() {
            const n = parseInt(document.getElementById('mi').value);
            if (!n || n < 1) return;
            const mu = mobius(n), f = primeFactors(n);
            const u = [...new Set(f)];
            const sqfree = f.length === u.length;
            const interp = mu === 0 ? 'Not square-free' : mu === 1 ? 'Even # of distinct primes' : 'Odd # of distinct primes';
            document.getElementById('mr2').innerHTML = `
                <p><b>μ(${n}) = ${mu}</b></p>
                <p>${interp}</p>
                <p>Factors: ${f.join(' × ')}</p>
                <p>${sqfree ? 'Square-free ✓' : 'Not square-free ✗'}</p>
            `;
        }

        function calcPrime() {
            const n = parseInt(document.getElementById('pi').value);
            if (!n || n < 2) return;
            const f = primeFactors(n);
            const fc = {};
            f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}<sup>${c}</sup>` : p).join(' × ');
            document.getElementById('pr').innerHTML = `
                <p><b>${n} = ${fs}</b></p>
                <p>${isPrime(n) ? '<span style="color:var(--green)">Prime</span>' : '<span style="color:var(--blue)">Composite</span>'}</p>
                <p>Distinct primes: ${Object.keys(fc).length}</p>
            `;
        }

        function checkCoprime() {
            const inp = document.getElementById('cci').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('ccr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1;
            document.getElementById('ccr').innerHTML = `
                <p><b>Numbers:</b> ${nums.join(', ')}</p>
                <p><b>GCD:</b> ${g}</p>
                <p style="font-size:1.2em; margin-top:10px">${coprime ? '<span style="color:var(--green)">✓ COPRIME (Primitive point)</span>' : '<span style="color:var(--red)">✗ NOT COPRIME (Non-primitive)</span>'}</p>
            `;
        }

        function searchPoint() {
            const inp = document.getElementById('psi').value;
            const coords = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (coords.length < 2) {
                document.getElementById('psr').innerHTML = '<p style="color:var(--red)">Need 2+ coordinates</p>';
                return;
            }
            const g = gcdArray(coords);
            const isPrim = g === 1;
            const dist = Math.sqrt(coords.reduce((sum, x) => sum + x*x, 0));
            document.getElementById('psr').innerHTML = `
                <p><b>Point:</b> (${coords.join(', ')})</p>
                <p><b>GCD:</b> ${g}</p>
                <p><b>Distance from origin:</b> ${dist.toFixed(3)}</p>
                <p><b>Dimension:</b> ${coords.length}</p>
                <p style="font-size:1.2em; margin-top:10px">${isPrim ? '<span style="color:var(--green)">✓ PRIMITIVE</span>' : '<span style="color:var(--red)">✗ NON-PRIMITIVE</span>'}</p>
            `;
        }

        function exportCanvas(canvasId, filename) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = `${filename}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function exportPointData2D() {
            if (!cache.points2D) { alert('Generate 2D visualization first'); return; }
            const data = cache.points2D;
            let csv = 'x,y,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},non-primitive\n`);
            downloadCSV(csv, '2d-lattice-points.csv');
        }

        function export3DData() {
            if (!cache.points3D) { alert('Generate 3D visualization first'); return; }
            const data = cache.points3D;
            let csv = 'x,y,z,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},${p.z},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},${p.z},non-primitive\n`);
            downloadCSV(csv, '3d-lattice-points.csv');
        }

        function exportTheoryData() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            const z = zeta(k);
            const vol = sphereVolume(k, R);
            const pred = Math.round(vol / z);
            
            let csv = 'dimension,radius,zeta,density,volume,predicted_points\n';
            csv += `${k},${R},${z},${1/z},${vol},${pred}\n`;
            downloadCSV(csv, 'theory-data.csv');
        }

        function exportChartData() {
            if (!chart) { alert('Run analysis first'); return; }
            const data = chart.data.datasets[0].data;
            let csv = 'radius,error\n';
            data.forEach(pt => csv += `${pt.x},${pt.y}\n`);
            downloadCSV(csv, 'error-analysis.csv');
        }

        function exportComparisonData() {
            const R = parseInt(document.getElementById('cr').value);
            let csv = 'dimension,zeta,density,volume,predicted_points\n';
            for (let k = 2; k <= 6; k++) {
                const z = zeta(k);
                const vol = sphereVolume(k, R);
                const pred = Math.round(vol / z);
                csv += `${k},${z},${1/z},${vol},${pred}\n`;
            }
            downloadCSV(csv, 'dimension-comparison.csv');
        }

        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        function toggleDark() {
            document.body.classList.toggle('dark');
            const btn = document.getElementById('darkBtn');
            btn.textContent = document.body.classList.contains('dark') ? 'Light Mode' : 'Dark Mode';
            if (scene) scene.background = new THREE.Color(document.body.classList.contains('dark') ? 0x1a1a1a : 0xffffff);
        }

        function showHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('active');
        }

        function showDerivationAnimation() {
            alert('Interactive animation coming soon! This would show step-by-step how Möbius inversion leads to the zeta function connection.');
        }

        // Init
        updateTheory();
        const tb = document.getElementById('tbl');
        for (let k = 2; k <= 12; k++) {
            const z = zeta(k);
            const v = k % 2 === 0 ? 
                (Math.PI**(k/2) / factorial(k/2)).toFixed(4) :
                (2 * factorial((k-1)/2) * Math.PI**((k-1)/2) / factorial(k)).toFixed(4);
            tb.innerHTML += `<tr><td>${k}</td><td>${z.toFixed(4)}</td><td>${(1/z).toFixed(4)}</td><td>${v}</td></tr>`;
        }
        
        document.getElementById('helpModal').addEventListener('click', e => {
            if (e.target.id === 'helpModal') closeHelp();
        });
    </script>
</body>
</html>
