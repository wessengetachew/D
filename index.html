
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mathematical Discovery Platform</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg: #1a1a1a; --bg2: #2d2d2d; --bg3: #3a3a3a; --text: #e0e0e0; --text2: #b0b0b0;
            --border: #4a4a4a; --blue: #0066cc; --purple: #6f42c1; --green: #28a745; --red: #dc3545;
            --yellow: #ffc107; --orange: #fd7e14;
        }
        body.light { --bg: #fff; --bg2: #f8f9fa; --bg3: #e9ecef; --text: #212529; --text2: #495057; --border: #dee2e6; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui; background: var(--bg); color: var(--text); line-height: 1.6; transition: background 0.3s, color 0.3s; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; padding: 40px 20px; background: linear-gradient(135deg, var(--blue), var(--purple));
            color: white; border-radius: 12px; margin-bottom: 30px; position: relative; overflow: hidden; }
        .header::before { content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%); animation: pulse 4s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .header h1 { font-size: 2.5rem; margin-bottom: 10px; position: relative; z-index: 1; }
        .header p { position: relative; z-index: 1; }
        .tabs { display: flex; gap: 5px; margin-bottom: 30px; background: var(--bg2); padding: 10px; border-radius: 12px; flex-wrap: wrap; }
        .tab-btn { flex: 1; min-width: 120px; padding: 12px 20px; border: none; background: var(--bg3); color: var(--text);
            cursor: pointer; border-radius: 8px; font-weight: 600; transition: all 0.3s; }
        .tab-btn:hover { background: var(--blue); color: white; transform: translateY(-2px); }
        .tab-btn.active { background: var(--blue); color: white; box-shadow: 0 4px 12px rgba(0,102,204,0.3); }
        .controls button.active { background: var(--purple); }
        .panel { display: none; animation: fadeIn 0.5s; }
        .panel.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .section { background: var(--bg2); padding: 30px; border-radius: 12px; margin-bottom: 30px; transition: all 0.3s; }
        .section:hover { box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
        .section h2 { color: var(--blue); margin-bottom: 20px; display: flex; align-items: center; gap: 10px; }
        .help-icon { display: inline-block; width: 20px; height: 20px; background: var(--blue); color: white;
            border-radius: 50%; text-align: center; line-height: 20px; font-size: 12px; cursor: help; }
        .tooltip { position: relative; }
        .tooltip:hover::after { content: attr(data-tip); position: absolute; bottom: 125%; left: 50%;
            transform: translateX(-50%); padding: 8px 12px; background: var(--text); color: var(--bg);
            border-radius: 6px; white-space: nowrap; z-index: 1000; font-size: 12px; }
        .controls { margin: 20px 0; padding: 20px; background: var(--bg3); border-radius: 8px; }
        .controls label { display: block; margin: 10px 0; font-weight: 600; }
        .controls input[type="range"] { width: 100%; }
        .controls button { padding: 10px 20px; background: var(--blue); color: white; border: none;
            border-radius: 6px; cursor: pointer; margin: 5px; transition: all 0.3s; }
        .controls button:hover { background: var(--purple); transform: scale(1.05); }
        .controls button:disabled { background: var(--text2); cursor: not-allowed; transform: none; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }
        .stat { background: var(--bg3); padding: 20px; border-radius: 8px; text-align: center; transition: all 0.3s; }
        .stat:hover { transform: translateY(-5px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .stat .val { font-size: 2rem; font-weight: bold; color: var(--blue); transition: all 0.5s; }
        .stat .lbl { font-size: 0.9rem; color: var(--text2); }
        canvas { border: 2px solid var(--border); border-radius: 8px; display: block; margin: 20px auto; max-width: 100%; }
        #canvas3d { width: 100%; height: 600px; cursor: grab; }
        #canvas3d:active { cursor: grabbing; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; overflow-x: auto; display: block; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--bg3); color: var(--blue); font-weight: 600; position: sticky; top: 0; }
        .btn-fixed { position: fixed; bottom: 20px; padding: 12px 24px; border: none; border-radius: 25px;
            cursor: pointer; font-weight: 600; z-index: 1000; color: white; transition: all 0.3s; }
        .btn-fixed:hover { transform: translateY(-3px); box-shadow: 0 6px 20px rgba(0,0,0,0.3); }
        #darkBtn { right: 20px; background: var(--blue); }
        #helpBtn { right: 140px; background: var(--green); }
        .formula { background: var(--bg3); padding: 20px; border-left: 4px solid var(--blue); border-radius: 8px; margin: 20px 0; }
        .warning { background: #3d3106; color: #ffc107; padding: 15px; border-left: 4px solid var(--yellow); border-radius: 8px; margin: 20px 0; }
        body.light .warning { background: #fff3cd; color: #856404; }
        .loading { display: none; text-align: center; padding: 20px; }
        .loading.active { display: block; }
        .spinner { border: 4px solid var(--border); border-top: 4px solid var(--blue); border-radius: 50%;
            width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .compare-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .compare-item { background: var(--bg3); padding: 15px; border-radius: 8px; }
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7);
            z-index: 2000; align-items: center; justify-content: center; }
        .modal.active { display: flex; }
        .modal-content { background: var(--bg); padding: 30px; border-radius: 12px; max-width: 600px; max-height: 80vh;
            overflow-y: auto; position: relative; }
        .modal-close { position: absolute; top: 10px; right: 10px; font-size: 24px; cursor: pointer; color: var(--text2); }
        .export-buttons { display: flex; gap: 10px; flex-wrap: wrap; }
        .data-table-container { max-height: 400px; overflow-y: auto; }
        @media (max-width: 768px) {
            .header h1 { font-size: 1.8rem; }
            .tabs { flex-direction: column; }
            .tab-btn { min-width: 100%; }
            #canvas3d { height: 400px; }
            .btn-fixed { padding: 10px 16px; font-size: 14px; }
            #helpBtn { right: 20px; bottom: 70px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <h1>Mathematical Discovery Platform</h1>
            <p>Primitive Lattice Points & Boundary Cancellation</p>
            <p style="margin-top:10px; font-size:0.9rem">By Wessen Getachew | <a href="https://twitter.com/7dview" style="color:white">@7dview</a></p>
        </header>

        <nav class="tabs">
            <button class="tab-btn active" onclick="showTab('theory')">Theory</button>
            <button class="tab-btn" onclick="showTab('applications')">Applications</button>
            <button class="tab-btn" onclick="showTab('viz2d')">2D Viz</button>
            <button class="tab-btn" onclick="showTab('viz3d')">3D Viz</button>
            <button class="tab-btn" onclick="showTab('comparison')">Compare</button>
            <button class="tab-btn" onclick="showTab('analysis')">Analysis</button>
            <button class="tab-btn" onclick="showTab('tools')">Tools</button>
            <button class="tab-btn" onclick="showTab('derivation')">Derivation</button>
        </nav>

        <div id="theory" class="panel active">
            <div class="section">
                <h2>Abstract <span class="help-icon tooltip" data-tip="Core theoretical framework">?</span></h2>
                <p>We present a framework for counting primitive lattice points in k-dimensional spheres. Points (x₁, x₂, ..., xₖ) with gcd(x₁, x₂, ..., xₖ) = 1 follow the asymptotic formula:</p>
                <div class="formula">$$N_k(R) = \frac{V_k R^k}{\zeta(k)} + O(R^{k-1})$$</div>
                <p style="margin-top:15px">Where V_k is the volume of the unit k-sphere and ζ(k) is the Riemann zeta function. The density of primitive points approaches 1/ζ(k) as R → ∞.</p>
            </div>
            
            <div class="section">
                <h2>Boundary Cancellation Principle</h2>
                <p>The key insight is that non-primitive points (those sharing a common factor d > 1) can be expressed as d·(primitive point). Through Möbius inversion, we show that boundary contributions from non-primitive points cancel systematically, leaving only the volume term divided by ζ(k).</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) \cdot |\{(x_1,...,x_k) : \sum x_i^2 \leq (R/d)^2\}|$$</div>
                <p style="margin-top:15px">The Möbius function μ(d) = (-1)^ω(d) for square-free d (where ω counts distinct prime factors) ensures alternating cancellation of boundary terms.</p>
            </div>

            <div class="section">
                <h2>Interactive Explorer <span class="help-icon tooltip" data-tip="Adjust parameters to see predictions">?</span></h2>
                <div class="controls">
                    <label>Dimension k: <span id="tk">3</span></label>
                    <input type="range" id="tks" min="2" max="12" value="3" oninput="updateTheory()">
                    <label>Radius R: <span id="tr">50</span></label>
                    <input type="range" id="trs" min="10" max="200" value="50" step="10" oninput="updateTheory()">
                    <button onclick="exportTheoryData()">Export Data</button>
                </div>
                <div class="stats">
                    <div class="stat"><div class="val" id="sz">1.202</div><div class="lbl">ζ(k)</div></div>
                    <div class="stat"><div class="val" id="sp">4186</div><div class="lbl">Predicted N_k(R)</div></div>
                    <div class="stat"><div class="val" id="sd">0.832</div><div class="lbl">Density (1/ζ(k))</div></div>
                    <div class="stat"><div class="val" id="svol">523.6</div><div class="lbl">Sphere Volume</div></div>
                </div>
                <div class="data-table-container">
                    <table><thead><tr><th>k</th><th>ζ(k)</th><th>1/ζ(k)</th><th>V_k (unit sphere)</th></tr></thead><tbody id="tbl"></tbody></table>
                </div>
            </div>
        </div>

        <div id="applications" class="panel">
            <div class="section">
                <h2>Real-World Applications</h2>
                <h3>1. Cryptography & Number Theory</h3>
                <p>Primitive lattice points correspond to coprime integers, essential for:</p>
                <ul style="margin-left: 25px; margin-top: 10px;">
                    <li><b>RSA Key Generation:</b> Finding large coprime numbers for secure encryption</li>
                    <li><b>Lattice-Based Cryptography:</b> Post-quantum security relies on hard lattice problems</li>
                    <li><b>Random Number Generation:</b> Coprime sequences provide high-quality randomness</li>
                </ul>

                <h3 style="margin-top: 25px;">2. Physics & Crystallography</h3>
                <p>Lattice structures appear throughout nature:</p>
                <ul style="margin-left: 25px; margin-top: 10px;">
                    <li><b>Crystal Structures:</b> Atoms arrange in primitive lattice configurations</li>
                    <li><b>X-ray Diffraction:</b> Scattering patterns reveal lattice spacing</li>
                    <li><b>Quantum Mechanics:</b> Particle states in periodic potentials</li>
                </ul>

                <h3 style="margin-top: 25px;">3. Computer Graphics & Gaming</h3>
                <ul style="margin-left: 25px; margin-top: 10px;">
                    <li><b>Procedural Generation:</b> Creating diverse, non-repeating patterns</li>
                    <li><b>Collision Detection:</b> Efficient spatial partitioning using lattice grids</li>
                    <li><b>Texture Synthesis:</b> Generating natural-looking patterns</li>
                </ul>

                <h3 style="margin-top: 25px;">4. Data Science & Optimization</h3>
                <ul style="margin-left: 25px; margin-top: 10px;">
                    <li><b>Sampling Theory:</b> Optimal point distributions for numerical integration</li>
                    <li><b>Sphere Packing:</b> Information theory and error-correcting codes</li>
                    <li><b>High-Dimensional Statistics:</b> Understanding point distributions in many dimensions</li>
                </ul>
            </div>
        </div>

        <div id="viz2d" class="panel">
            <div class="section">
                <h2>2D Lattice Visualization <span class="help-icon tooltip" data-tip="Explore primitive lattice points">?</span></h2>
                <div class="controls">
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>View Mode:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="viewPrimitive" class="active" onclick="set2DView('primitive')" style="flex:1; min-width:150px; padding: 12px;">Colored by Mode</button>
                            <button id="viewGauss" onclick="set2DView('gauss')" style="flex:1; min-width:150px; padding: 12px;">Circle Problem (All Points)</button>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Coloring Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="color2DPrimitive" class="active" onclick="set2DColorMode('primitive')" style="padding:10px 12px; font-size:0.85em;">GCD=1 vs GCD>1</button>
                            <button id="color2DGCD" onclick="set2DColorMode('gcd')" style="padding:10px 12px; font-size:0.85em;">By GCD Value</button>
                            <button id="color2DMod" onclick="set2DColorMode('mod')" style="padding:10px 12px; font-size:0.85em;">By Mod m</button>
                            <button id="color2DQuadrant" onclick="set2DColorMode('quadrant')" style="padding:10px 12px; font-size:0.85em;">By Quadrant</button>
                            <button id="color2DAngular" onclick="set2DColorMode('angular')" style="padding:10px 12px; font-size:0.85em;">By Angular Sector</button>
                            <button id="color2DGCDQuad" onclick="set2DColorMode('gcdquad')" style="padding:10px 12px; font-size:0.85em;">GCD × Quadrant</button>
                            <button id="color2DGCDMod" onclick="set2DColorMode('gcdmod')" style="padding:10px 12px; font-size:0.85em;">GCD × Mod</button>
                        </div>
                        <div id="modControls2D" style="display:none; margin-top:10px;">
                            <label>Modulus m: <span id="mod2Dv">3</span></label>
                            <input type="range" id="mod2D" min="2" max="12" value="3" step="1" oninput="document.getElementById('mod2Dv').textContent=this.value; draw2D()">
                        </div>
                        <div id="sectorControls2D" style="display:none; margin-top:10px;">
                            <label>Angular Sectors: <span id="sectors2Dv">8</span></label>
                            <input type="range" id="sectors2D" min="4" max="16" value="8" step="1" oninput="document.getElementById('sectors2Dv').textContent=this.value; draw2D()">
                        </div>
                    </div>
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="set2DPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=10)</button>
                            <button onclick="set2DPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=50)</button>
                            <button onclick="set2DPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=100)</button>
                            <button onclick="set2DPreset('xlarge')" style="padding:6px 12px; font-size:0.9em;">X-Large (R=200)</button>
                        </div>
                    </div>
                    <label>Radius: <span id="r2v">20</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                        <input type="range" id="r2" min="1" max="500" value="20" step="1" oninput="update2DRadius(this.value)" style="flex:1;">
                        <input type="number" id="r2input" min="1" max="1000" value="20" style="width:100px; padding:8px;" oninput="update2DRadius(this.value)">
                    </div>
                    <label>Point Size: <span id="psv">3</span></label>
                    <input type="range" id="ps" min="1" max="10" value="3" oninput="draw2D()">
                    <button onclick="exportCanvas('c2d', '2d-lattice')">Export Image</button>
                    <button onclick="exportPointData2D()">Export Points</button>
                </div>
                <div class="warning" id="warn2d" style="display:none;">
                    ⚠️ Large radius values may slow performance. Consider using R ≤ 200 for smooth rendering.
                </div>
                <div class="loading" id="load2d"><div class="spinner"></div><p>Computing lattice points...</p></div>
                <canvas id="c2d" width="800" height="800"></canvas>
                <div class="stats">
                    <div class="stat"><div class="val" id="p2">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t2">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d2">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e2">0</div><div class="lbl">|Predicted - Actual|</div></div>
                </div>
            </div>
        </div>

        <div id="viz3d" class="panel">
            <div class="section">
                <h2>3D Lattice Visualization <span class="help-icon tooltip" data-tip="Click and drag to rotate">?</span></h2>
                <div class="controls">
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Boundary Shape:</b></label>
                        <div style="display:flex; gap:10px; flex-wrap:wrap;">
                            <button id="shape3DSphere" class="active" onclick="set3DShape('sphere')" style="flex:1; min-width:120px; padding: 12px;">Sphere (x²+y²+z² ≤ R²)</button>
                            <button id="shape3DCube" onclick="set3DShape('cube')" style="flex:1; min-width:120px; padding: 12px;">Cube (|x|,|y|,|z| ≤ R)</button>
                        </div>
                    </div>
                    
                    <div style="background: var(--bg3); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <label style="font-size: 1.1em; color: var(--blue); margin-bottom: 10px; display: block;"><b>Coloring Mode:</b></label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap:8px;">
                            <button id="colorPrimitive" class="active" onclick="set3DColorMode('primitive')" style="padding:10px 12px; font-size:0.85em;">GCD=1 vs GCD>1</button>
                            <button id="colorGCD" onclick="set3DColorMode('gcd')" style="padding:10px 12px; font-size:0.85em;">By GCD Value</button>
                            <button id="colorMod" onclick="set3DColorMode('mod')" style="padding:10px 12px; font-size:0.85em;">By Mod m</button>
                            <button id="colorOctant" onclick="set3DColorMode('octant')" style="padding:10px 12px; font-size:0.85em;">By Octant</button>
                            <button id="colorDistance" onclick="set3DColorMode('distance')" style="padding:10px 12px; font-size:0.85em;">By Distance</button>
                            <button id="colorGCDOct" onclick="set3DColorMode('gcdoct')" style="padding:10px 12px; font-size:0.85em;">GCD × Octant</button>
                            <button id="colorGCDMod" onclick="set3DColorMode('gcdmod')" style="padding:10px 12px; font-size:0.85em;">GCD × Mod</button>
                        </div>
                        <div id="modControls3D" style="display:none; margin-top:10px;">
                            <label>Modulus m: <span id="mod3Dv">3</span></label>
                            <input type="range" id="mod3D" min="2" max="12" value="3" step="1" oninput="document.getElementById('mod3Dv').textContent=this.value; draw3D()">
                        </div>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="set3DPreset('tiny')" style="padding:6px 12px; font-size:0.9em;">Tiny (R=5)</button>
                            <button onclick="set3DPreset('small')" style="padding:6px 12px; font-size:0.9em;">Small (R=10)</button>
                            <button onclick="set3DPreset('medium')" style="padding:6px 12px; font-size:0.9em;">Medium (R=20)</button>
                            <button onclick="set3DPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large (R=30)</button>
                        </div>
                    </div>
                    <label>Radius: <span id="r3v">10</span></label>
                    <input type="range" id="r3" min="1" max="40" value="10" step="1" oninput="draw3D()">
                    
                    <label>Point Size: <span id="ps3v">0.6</span></label>
                    <input type="range" id="ps3" min="0.2" max="2.0" value="0.6" step="0.1" oninput="draw3D()">
                    
                    <button onclick="reset3D()">Reset View</button>
                    <button onclick="toggleRotation()">Auto-Rotate</button>
                    <button onclick="export3DData()">Export Points</button>
                </div>
                <div class="warning" id="warn3d" style="display:none;">
                    ⚠️ Radius > 30 generates many points and may impact performance.
                </div>
                <div class="loading" id="load3d"><div class="spinner"></div><p>Generating 3D lattice...</p></div>
                <div id="c3d"></div>
                <div class="stats">
                    <div class="stat"><div class="val" id="p3">0</div><div class="lbl">Primitive Points</div></div>
                    <div class="stat"><div class="val" id="t3">0</div><div class="lbl">Total Points</div></div>
                    <div class="stat"><div class="val" id="d3">0%</div><div class="lbl">Density</div></div>
                    <div class="stat"><div class="val" id="e3">0</div><div class="lbl">Error</div></div>
                </div>
            </div>
        </div>

        <div id="comparison" class="panel">
            <div class="section">
                <h2>Dimension Comparison <span class="help-icon tooltip" data-tip="Compare different dimensions">?</span></h2>
                <p>Compare how primitive lattice point counts change across dimensions for a fixed radius, or analyze how different radii affect each dimension.</p>
                
                <div class="controls">
                    <label>Comparison Mode:</label>
                    <div style="display:flex; gap:10px; margin-bottom:15px; flex-wrap:wrap;">
                        <button id="modeFixed" class="active" onclick="setComparisonMode('fixed')" style="flex:1; min-width:150px;">Fixed Radius</button>
                        <button id="modeMulti" onclick="setComparisonMode('multi')" style="flex:1; min-width:150px;">Multiple Radii</button>
                    </div>
                    
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setComparisonPreset('low')" style="padding:6px 12px; font-size:0.9em;">Low Dimensions (2-4)</button>
                            <button onclick="setComparisonPreset('mid')" style="padding:6px 12px; font-size:0.9em;">Mid Dimensions (3-6)</button>
                            <button onclick="setComparisonPreset('high')" style="padding:6px 12px; font-size:0.9em;">High Dimensions (5-10)</button>
                            <button onclick="setComparisonPreset('all')" style="padding:6px 12px; font-size:0.9em;">All Dimensions (2-10)</button>
                            <button onclick="setComparisonPreset('growth')" style="padding:6px 12px; font-size:0.9em;">Growth Analysis</button>
                        </div>
                    </div>
                    
                    <div id="fixedRadiusControls">
                        <label>Radius: <span id="crv">15</span></label>
                        <div style="display:flex; gap:10px; align-items:center; margin-bottom:15px;">
                            <input type="range" id="cr" min="1" max="100" value="15" step="1" oninput="updateComparisonRadius(this.value)" style="flex:1;">
                            <input type="number" id="crinput" min="1" max="200" value="15" style="width:100px; padding:8px;" oninput="updateComparisonRadius(this.value)">
                        </div>
                    </div>
                    
                    <div id="multiRadiusControls" style="display:none;">
                        <label>Radii to compare (comma-separated): </label>
                        <input type="text" id="multiRadii" value="10, 20, 30, 40, 50" style="width:100%; padding:10px; margin-bottom:15px;" oninput="updateComparison()">
                    </div>
                    
                    <div style="margin-bottom:15px;">
                        <p><b>Dimensions to compare:</b></p>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap:10px; margin-top:10px;">
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk2" checked onchange="updateComparison()"> k=2
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk3" checked onchange="updateComparison()"> k=3
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk4" checked onchange="updateComparison()"> k=4
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk5" checked onchange="updateComparison()"> k=5
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk6" checked onchange="updateComparison()"> k=6
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk7" onchange="updateComparison()"> k=7
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk8" onchange="updateComparison()"> k=8
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk9" onchange="updateComparison()"> k=9
                            </label>
                            <label style="display:flex; align-items:center; gap:8px;">
                                <input type="checkbox" id="compk10" onchange="updateComparison()"> k=10
                            </label>
                        </div>
                    </div>
                    
                    <div style="margin-bottom:15px;">
                        <p><b>Display options:</b></p>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showDensity" checked onchange="updateComparison()"> Show Density (1/ζ(k))
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showVolume" checked onchange="updateComparison()"> Show Sphere Volume
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showZeta" checked onchange="updateComparison()"> Show ζ(k) Values
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showChart" checked onchange="updateComparison()"> Show Comparison Chart
                        </label>
                    </div>
                    
                    <button onclick="updateComparison()">Refresh Comparison</button>
                    <button onclick="exportComparisonData()">Export Data</button>
                    <button onclick="exportComparisonChart()">Export Chart</button>
                </div>
                
                <div class="compare-grid" id="compGrid"></div>
                
                <div id="comparisonChart" style="margin-top:30px;">
                    <canvas id="compChart" width="800" height="400"></canvas>
                </div>
                
                <div class="formula" style="margin-top:20px;">
                    <p><b>Key Observations:</b></p>
                    <p>• As dimension k increases, ζ(k) approaches 1, meaning the density 1/ζ(k) approaches 100%</p>
                    <p>• Higher dimensions have exponentially more lattice points (grows as R^k)</p>
                    <p>• The ratio of primitive to total points stabilizes at 1/ζ(k) for each dimension</p>
                    <p>• Sphere volume grows dramatically with dimension, following the gamma function pattern</p>
                </div>
            </div>
        </div>

        <div id="analysis" class="panel">
            <div class="section">
                <h2>Error Analysis <span class="help-icon tooltip" data-tip="Study O(R^(k-1)) error term">?</span></h2>
                <p>Visualization of the error term Δ(R) for different dimensions. The chart shows absolute and relative errors for each radius value.</p>
                <div class="controls">
                    <div style="margin-bottom:10px;">
                        <label><b>Presets:</b></label>
                        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-top:5px;">
                            <button onclick="setAnalysisPreset('quick')" style="padding:6px 12px; font-size:0.9em;">Quick (R≤50)</button>
                            <button onclick="setAnalysisPreset('standard')" style="padding:6px 12px; font-size:0.9em;">Standard (R≤100)</button>
                            <button onclick="setAnalysisPreset('detailed')" style="padding:6px 12px; font-size:0.9em;">Detailed (R≤150)</button>
                            <button onclick="setAnalysisPreset('absolute')" style="padding:6px 12px; font-size:0.9em;">Absolute Only</button>
                            <button onclick="setAnalysisPreset('relative')" style="padding:6px 12px; font-size:0.9em;">Relative Only</button>
                            <button onclick="setAnalysisPreset('boundary')" style="padding:6px 12px; font-size:0.9em;">Boundary Only</button>
                        </div>
                    </div>
                    
                    <label>Dimension k: <span id="analysisKv">2</span></label>
                    <input type="range" id="analysisK" min="2" max="5" value="2" step="1" oninput="document.getElementById('analysisKv').textContent=this.value">
                    
                    <label>Max Radius: <span id="mrv">100</span></label>
                    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
                        <input type="range" id="mr" min="10" max="200" value="100" step="5" oninput="updateAnalysisRadius(this.value)" style="flex:1;">
                        <input type="number" id="mrinput" min="10" max="300" value="100" step="5" style="width:100px; padding:8px;" oninput="updateAnalysisRadius(this.value)">
                    </div>
                    
                    <label>Start from Radius: <span id="minrv">1</span></label>
                    <input type="range" id="minr" min="1" max="50" value="1" step="1" oninput="document.getElementById('minrv').textContent=this.value">
                    
                    <div style="margin-top:20px;">
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showAbsError" checked onchange="runAnalysis()"> Show Absolute Error
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showRelError" checked onchange="runAnalysis()"> Show Relative Error (%)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showBoundary" onchange="runAnalysis()"> Show Theoretical Boundary R^(k-1)
                        </label>
                        <label style="display:flex; align-items:center; gap:8px; margin:8px 0;">
                            <input type="checkbox" id="showActualCount" onchange="runAnalysis()"> Show Actual Primitive Count
                        </label>
                    </div>
                    
                    <button onclick="runAnalysis()" style="margin-top:15px;">Compute Analysis</button>
                    <button onclick="exportChartData()">Export Chart Data</button>
                </div>
                <div class="loading" id="loadAnalysis"><div class="spinner"></div><p>Computing error analysis...</p></div>
                <canvas id="ch" width="1600" height="1000" style="max-width: 100%;"></canvas>
                <div class="formula" style="margin-top: 20px;">
                    <p><b>Error Bound Theory:</b></p>
                    <p>The error term O(R^(k-1)) arises from boundary effects. For k=2, the error is O(R), corresponding to points near the circle boundary. As k increases, the error term becomes relatively smaller compared to the main term R^k.</p>
                    <p style="margin-top:10px;"><b>Relative Error:</b> Shows |Predicted - Actual| / Predicted as a percentage. This decreases as R grows, confirming the asymptotic accuracy.</p>
                    <p style="margin-top:10px;"><b>Boundary Term:</b> The theoretical R^(k-1) term, showing the expected growth rate of the error.</p>
                </div>
            </div>
        </div>

        <div id="tools" class="panel">
            <div class="section">
                <h2>Mathematical Tools <span class="help-icon tooltip" data-tip="Number theory utilities">?</span></h2>
                
                <h3>GCD Calculator</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setGCDPreset('coprime')" style="padding:6px 12px; font-size:0.9em;">Coprime Example</button>
                        <button onclick="setGCDPreset('common')" style="padding:6px 12px; font-size:0.9em;">Common Factor</button>
                        <button onclick="setGCDPreset('large')" style="padding:6px 12px; font-size:0.9em;">Large Numbers</button>
                        <button onclick="setGCDPreset('many')" style="padding:6px 12px; font-size:0.9em;">Many Numbers</button>
                    </div>
                    <input type="text" id="gi" placeholder="12, 18, 24" style="width:100%; padding:10px">
                    <button onclick="calcGCD()">Calculate</button>
                    <div id="gr" style="margin-top:15px"></div>
                </div>

                <h3>Möbius Function μ(n)</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setMobiusPreset('squarefree')" style="padding:6px 12px; font-size:0.9em;">Square-free</button>
                        <button onclick="setMobiusPreset('notsquarefree')" style="padding:6px 12px; font-size:0.9em;">Not Square-free</button>
                        <button onclick="setMobiusPreset('prime')" style="padding:6px 12px; font-size:0.9em;">Prime Number</button>
                        <button onclick="setMobiusPreset('composite')" style="padding:6px 12px; font-size:0.9em;">Large Composite</button>
                    </div>
                    <input type="number" id="mi" placeholder="30" style="width:100%; padding:10px" min="1">
                    <button onclick="calcMobius()">Calculate</button>
                    <div id="mr2" style="margin-top:15px"></div>
                </div>

                <h3>Prime Factorization</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setPrimePreset('small')" style="padding:6px 12px; font-size:0.9em;">Small Number</button>
                        <button onclick="setPrimePreset('perfect')" style="padding:6px 12px; font-size:0.9em;">Perfect Number</button>
                        <button onclick="setPrimePreset('highly')" style="padding:6px 12px; font-size:0.9em;">Highly Composite</button>
                        <button onclick="setPrimePreset('large')" style="padding:6px 12px; font-size:0.9em;">Large Number</button>
                        <button onclick="setPrimePreset('power')" style="padding:6px 12px; font-size:0.9em;">Prime Power</button>
                    </div>
                    <input type="number" id="pi" placeholder="360" style="width:100%; padding:10px" min="2">
                    <button onclick="calcPrime()">Factorize</button>
                    <div id="pr" style="margin-top:15px"></div>
                </div>

                <h3>Coprimality Checker</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setCoprimePreset('coprime2')" style="padding:6px 12px; font-size:0.9em;">Coprime Pair</button>
                        <button onclick="setCoprimePreset('notcoprime2')" style="padding:6px 12px; font-size:0.9em;">Non-Coprime Pair</button>
                        <button onclick="setCoprimePreset('coprime3')" style="padding:6px 12px; font-size:0.9em;">Coprime Triple</button>
                        <button onclick="setCoprimePreset('consecutive')" style="padding:6px 12px; font-size:0.9em;">Consecutive Numbers</button>
                    </div>
                    <input type="text" id="cci" placeholder="15, 28" style="width:100%; padding:10px">
                    <button onclick="checkCoprime()">Check</button>
                    <div id="ccr" style="margin-top:15px"></div>
                </div>

                <h3>Point Search</h3>
                <div class="controls">
                    <div style="display:flex; gap:8px; margin-bottom:10px; flex-wrap:wrap;">
                        <button onclick="setPointPreset('pythagorean')" style="padding:6px 12px; font-size:0.9em;">Pythagorean Triple</button>
                        <button onclick="setPointPreset('primitive2d')" style="padding:6px 12px; font-size:0.9em;">Primitive 2D</button>
                        <button onclick="setPointPreset('nonprimitive2d')" style="padding:6px 12px; font-size:0.9em;">Non-Primitive 2D</button>
                        <button onclick="setPointPreset('primitive3d')" style="padding:6px 12px; font-size:0.9em;">Primitive 3D</button>
                        <button onclick="setPointPreset('highd')" style="padding:6px 12px; font-size:0.9em;">High-D Point</button>
                    </div>
                    <input type="text" id="psi" placeholder="3, 4 (finds if primitive)" style="width:100%; padding:10px">
                    <button onclick="searchPoint()">Search</button>
                    <div id="psr" style="margin-top:15px"></div>
                </div>
            </div>
        </div>

        <div id="derivation" class="panel">
            <div class="section">
                <h2>Interactive Derivation</h2>
                
                <h3>Step 1: Counting Lattice Points</h3>
                <p>Start with all lattice points in a k-dimensional sphere of radius R:</p>
                <div class="formula">$$L_k(R) = |\{(x_1,...,x_k) \in \mathbb{Z}^k : x_1^2 + ... + x_k^2 \leq R^2\}|$$</div>
                <p>Asymptotically, this equals the volume: L_k(R) ~ V_k R^k</p>

                <h3>Step 2: Separating by GCD</h3>
                <p>Partition points by their greatest common divisor d:</p>
                <div class="formula">$$L_k(R) = \sum_{d=1}^{R} N_k(R/d)$$</div>
                <p>Where N_k(R/d) counts primitive points in a sphere of radius R/d.</p>

                <h3>Step 3: Möbius Inversion</h3>
                <p>Inverting the previous relation using Möbius function:</p>
                <div class="formula">$$N_k(R) = \sum_{d=1}^{R} \mu(d) L_k(R/d)$$</div>
                
                <h3>Step 4: Asymptotic Expansion</h3>
                <p>Substituting L_k(R/d) ~ V_k (R/d)^k:</p>
                <div class="formula">$$N_k(R) = V_k R^k \sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} + O(R^{k-1})$$</div>

                <h3>Step 5: Zeta Connection</h3>
                <p>The sum equals the reciprocal of the zeta function:</p>
                <div class="formula">$$\sum_{d=1}^{\infty} \frac{\mu(d)}{d^k} = \frac{1}{\zeta(k)}$$</div>
                
                <h3>Final Result</h3>
                <div class="formula">$$N_k(R) = \frac{V_k R^k}{\zeta(k)} + O(R^{k-1})$$</div>
                <p>This elegant formula connects geometry (V_k), analysis (ζ(k)), and number theory (primitive points)!</p>
                
                <div class="controls" style="margin-top: 30px;">
                    <button onclick="showDerivationAnimation()">Animate Derivation</button>
                </div>
            </div>
        </div>
    </div>

    <button class="btn-fixed" id="helpBtn" onclick="showHelp()">Help</button>
    <button class="btn-fixed" id="darkBtn" onclick="toggleDark()">Light Mode</button>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <span class="modal-close" onclick="closeHelp()">&times;</span>
            <h2>Platform Guide</h2>
            <h3>Navigation</h3>
            <p>Use the tabs to explore different aspects of primitive lattice points.</p>
            
            <h3>2D Visualizations</h3>
            <p><b>View Modes:</b></p>
            <p>• <b>Colored by Mode:</b> Points colored according to selected coloring mode</p>
            <p>• <b>Gauss Circle Problem:</b> All lattice points in purple, comparing against πR²</p>
            
            <p style="margin-top:15px;"><b>Coloring Modes (2D):</b></p>
            <p>• <b>GCD=1 vs GCD>1:</b> Blue for primitive (coprime), red for non-primitive</p>
            <p>• <b>By GCD Value:</b> Different color for each GCD (1=blue, 2=red, 3=green, 4=yellow, etc.)</p>
            <p>• <b>By Mod m:</b> Colors based on (x+y) mod m - reveals modular patterns</p>
            <p>• <b>By Quadrant:</b> Four colors for four quadrants (I=blue, II=green, III=yellow, IV=red)</p>
            <p>• <b>By Angular Sector:</b> Rainbow colors dividing circle into sectors</p>
            <p>• <b>GCD × Quadrant:</b> Combined coloring showing both GCD structure and spatial position</p>
            <p>• <b>GCD × Mod:</b> Combined coloring revealing GCD and modular arithmetic patterns</p>
            
            <h3>3D Visualizations</h3>
            <p><b>Boundary Shapes:</b></p>
            <p>• Sphere: Points within distance R (x²+y²+z² ≤ R²)</p>
            <p>• Cube: Points within cube of side 2R (|x|,|y|,|z| ≤ R)</p>
            
            <p style="margin-top:15px;"><b>Coloring Modes (3D):</b></p>
            <p>• <b>GCD=1 vs GCD>1:</b> Blue for primitive, red for non-primitive</p>
            <p>• <b>By GCD Value:</b> Different colors for different GCD values</p>
            <p>• <b>By Mod m:</b> Colors based on (x+y+z) mod m</p>
            <p>• <b>By Octant:</b> Eight colors for eight octants in 3D space</p>
            <p>• <b>By Distance:</b> Gradient from center (blue) to boundary (red)</p>
            <p>• <b>GCD × Octant:</b> Combined coloring showing GCD and spatial structure</p>
            <p>• <b>GCD × Mod:</b> Combined GCD and modular arithmetic visualization</p>
            
            <p style="margin-top:10px;">Click and drag to rotate the view. Adjust point size for clarity.</p>
            
            <h3>Error Analysis</h3>
            <p>Shows error per radius value from start to max radius:</p>
            <p>• <b>Absolute Error:</b> |Predicted - Actual| count of points</p>
            <p>• <b>Relative Error:</b> Percentage error relative to prediction</p>
            <p>• <b>Boundary Term:</b> Theoretical R^(k-1) error bound</p>
            <p>• <b>Actual Count:</b> The true primitive point count at each radius</p>
            
            <h3>Performance Tips</h3>
            <p>• Keep radius ≤ 100 in 2D, ≤ 30 in 3D for smooth performance</p>
            <p>• Use Export buttons to save data and images</p>
            <p>• Compare mode shows multiple dimensions simultaneously</p>
            
            <h3>Tools Section</h3>
            <p>Calculate GCD, Möbius function, prime factorizations, and search for specific lattice points.</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, chart, autoRotate = false;
        const cache = { mobius: new Map(), gcd: new Map(), points2D: null, points3D: null };
        let mouseDown = false, prevMouse = { x: 0, y: 0 };
        let view2D = 'primitive'; // 'primitive' or 'gauss'
        let comparisonMode = 'fixed'; // 'fixed' or 'multi'
        let comparisonChart = null;
        let shape3D = 'sphere'; // 'sphere' or 'cube'
        let colorMode3D = 'primitive'; // 'primitive', 'gcd', 'mod', 'octant', 'distance', 'gcdoct', 'gcdmod'
        let colorMode2D = 'primitive'; // 'primitive', 'gcd', 'mod', 'quadrant', 'angular', 'gcdquad', 'gcdmod'

        function gcd(a, b) {
            a = Math.abs(a); b = Math.abs(b);
            while (b) [a, b] = [b, a % b];
            return a;
        }

        function gcdArray(arr) { return arr.reduce((a, b) => gcd(a, b)); }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i <= Math.sqrt(n); i += 2)
                if (n % i === 0) return false;
            return true;
        }

        function primeFactors(n) {
            const f = []; let d = 2;
            while (n > 1) {
                while (n % d === 0) { f.push(d); n /= d; }
                d++; if (d * d > n && n > 1) { f.push(n); break; }
            }
            return f;
        }

        function mobius(n) {
            if (cache.mobius.has(n)) return cache.mobius.get(n);
            if (n === 1) return 1;
            const f = primeFactors(n), u = [...new Set(f)];
            const r = f.length !== u.length ? 0 : Math.pow(-1, f.length);
            cache.mobius.set(n, r);
            return r;
        }

        function zeta(k) {
            const z = { 2: Math.PI**2/6, 3: 1.2020569, 4: Math.PI**4/90, 5: 1.0369278, 6: Math.PI**6/945, 
                       7: 1.0083493, 8: Math.PI**8/9450, 9: 1.00200839, 10: 1.00099457, 11: 1.00049419, 12: 1.00024608 };
            return z[k] || 1 + 2**-k;
        }

        function sphereVolume(k, R) {
            const gamma = k % 2 === 0 ? 
                Math.PI**(k/2) / factorial(k/2) : 
                2 * factorial((k-1)/2) * Math.PI**((k-1)/2) / factorial(k);
            return gamma * R**k;
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let res = 1;
            for (let i = 2; i <= n; i++) res *= i;
            return res;
        }

        function animateValue(id, start, end, duration = 500) {
            const el = document.getElementById(id);
            const range = end - start;
            const increment = range / (duration / 16);
            let current = start;
            const timer = setInterval(() => {
                current += increment;
                if ((increment > 0 && current >= end) || (increment < 0 && current <= end)) {
                    el.textContent = typeof end === 'number' && end % 1 !== 0 ? end.toFixed(3) : Math.round(end).toLocaleString();
                    clearInterval(timer);
                } else {
                    el.textContent = typeof current === 'number' && current % 1 !== 0 ? current.toFixed(3) : Math.round(current).toLocaleString();
                }
            }, 16);
        }

        function showTab(id) {
            document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            event.target.classList.add('active');
            if (id === 'viz2d') draw2D();
            if (id === 'viz3d' && !scene) init3D();
            if (id === 'comparison') updateComparison();
        }

        function updateTheory() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            document.getElementById('tk').textContent = k;
            document.getElementById('tr').textContent = R;
            const z = zeta(k), d = 1/z;
            const vol = sphereVolume(k, R);
            const pred = Math.round(vol / z);
            
            animateValue('sz', parseFloat(document.getElementById('sz').textContent) || z, z);
            animateValue('sd', parseFloat(document.getElementById('sd').textContent) || d, d);
            animateValue('sp', parseInt(document.getElementById('sp').textContent.replace(/,/g, '')) || pred, pred);
            animateValue('svol', parseFloat(document.getElementById('svol').textContent) || vol, vol);
        }

        function set2DView(mode) {
            view2D = mode;
            document.querySelectorAll('#viewPrimitive, #viewGauss').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode === 'primitive' ? 'viewPrimitive' : 'viewGauss').classList.add('active');
            draw2D();
        }

        function set2DColorMode(mode) {
            colorMode2D = mode;
            document.querySelectorAll('#color2DPrimitive, #color2DGCD, #color2DMod, #color2DQuadrant, #color2DAngular, #color2DGCDQuad, #color2DGCDMod').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'primitive': 'color2DPrimitive',
                'gcd': 'color2DGCD',
                'mod': 'color2DMod',
                'quadrant': 'color2DQuadrant',
                'angular': 'color2DAngular',
                'gcdquad': 'color2DGCDQuad',
                'gcdmod': 'color2DGCDMod'
            };
            document.getElementById(btnIds[mode]).classList.add('active');
            
            // Show/hide modulus controls
            document.getElementById('modControls2D').style.display = (mode === 'mod' || mode === 'gcdmod') ? 'block' : 'none';
            document.getElementById('sectorControls2D').style.display = (mode === 'angular') ? 'block' : 'none';
            
            draw2D();
        }

        function update2DRadius(value) {
            const R = parseInt(value);
            if (R < 1 || R > 1000 || isNaN(R)) return;
            
            document.getElementById('r2v').textContent = R;
            document.getElementById('r2').value = Math.min(R, 500);
            document.getElementById('r2input').value = R;
            
            // Show performance warning
            document.getElementById('warn2d').style.display = R > 200 ? 'block' : 'none';
            
            draw2D();
        }

        function draw2D() {
            const canvas = document.getElementById('c2d'), ctx = canvas.getContext('2d');
            const R = parseInt(document.getElementById('r2input').value);
            const sz = parseInt(document.getElementById('ps').value);
            document.getElementById('r2v').textContent = R;
            document.getElementById('psv').textContent = sz;
            
            document.getElementById('warn2d').style.display = R > 200 ? 'block' : 'none';
            if (R > 250) {
                document.getElementById('load2d').classList.add('active');
            }
            
            setTimeout(() => {
                ctx.clearRect(0, 0, 800, 800);
                const cx = 400, cy = 400, sc = 350/R;
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--border');
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(cx, cy, R*sc, 0, 2*Math.PI); ctx.stroke();
                
                const allPoints = [];
                let prim = 0, tot = 0;
                
                // Collect all points with properties
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        if (x*x + y*y <= R*R) {
                            tot++;
                            const g = gcd(Math.abs(x), Math.abs(y));
                            const isPrimitive = g === 1;
                            if (isPrimitive) prim++;
                            
                            // Calculate quadrant
                            let quadrant;
                            if (x >= 0 && y >= 0) quadrant = 1;
                            else if (x < 0 && y >= 0) quadrant = 2;
                            else if (x < 0 && y < 0) quadrant = 3;
                            else quadrant = 4;
                            
                            // Calculate angle (0 to 2π)
                            const angle = Math.atan2(y, x) + Math.PI; // 0 to 2π
                            
                            allPoints.push({
                                x, y, gcd: g, isPrimitive, quadrant, angle,
                                sum: x + y
                            });
                        }
                    }
                }
                
                // Group points by color based on mode
                const pointsByColor = {};
                const modulus = parseInt(document.getElementById('mod2D').value);
                const numSectors = parseInt(document.getElementById('sectors2D').value);
                
                allPoints.forEach(pt => {
                    let colorKey;
                    
                    if (view2D === 'gauss') {
                        colorKey = 'all';
                    } else {
                        switch(colorMode2D) {
                            case 'primitive':
                                colorKey = pt.isPrimitive ? 'prim' : 'nonprim';
                                break;
                            case 'gcd':
                                colorKey = `gcd${Math.min(pt.gcd, 8)}`;
                                break;
                            case 'mod':
                                colorKey = `mod${((pt.x + pt.y) % modulus + modulus) % modulus}`;
                                break;
                            case 'quadrant':
                                colorKey = `quad${pt.quadrant}`;
                                break;
                            case 'angular':
                                const sector = Math.floor(pt.angle / (2 * Math.PI / numSectors));
                                colorKey = `sector${sector}`;
                                break;
                            case 'gcdquad':
                                colorKey = `gcd${Math.min(pt.gcd, 4)}_q${pt.quadrant}`;
                                break;
                            case 'gcdmod':
                                const modVal = ((pt.x + pt.y) % modulus + modulus) % modulus;
                                colorKey = `gcd${Math.min(pt.gcd, 4)}_m${modVal}`;
                                break;
                        }
                    }
                    
                    if (!pointsByColor[colorKey]) pointsByColor[colorKey] = [];
                    pointsByColor[colorKey].push(pt);
                });
                
                // Define color palettes
                const colors = {
                    all: '#6f42c1',
                    prim: '#0066cc',
                    nonprim: '#dc3545',
                    gcd1: '#0066cc', gcd2: '#dc3545', gcd3: '#28a745', gcd4: '#ffc107',
                    gcd5: '#6f42c1', gcd6: '#fd7e14', gcd7: '#00d4ff', gcd8: '#ff006e',
                    quad1: '#0066cc', quad2: '#28a745', quad3: '#ffc107', quad4: '#dc3545',
                    mod0: '#0066cc', mod1: '#dc3545', mod2: '#28a745', mod3: '#ffc107',
                    mod4: '#6f42c1', mod5: '#fd7e14', mod6: '#00d4ff', mod7: '#ff006e',
                    mod8: '#20c997', mod9: '#e83e8c', mod10: '#17a2b8', mod11: '#6610f2'
                };
                
                // Generate sector colors (rainbow)
                for (let i = 0; i < 16; i++) {
                    const hue = (i / 16) * 360;
                    colors[`sector${i}`] = `hsl(${hue}, 70%, 50%)`;
                }
                
                // Generate combined colors
                const baseColors = ['#0066cc', '#dc3545', '#28a745', '#ffc107'];
                for (let g = 1; g <= 4; g++) {
                    for (let q = 1; q <= 4; q++) {
                        colors[`gcd${g}_q${q}`] = baseColors[(g - 1 + q - 1) % 4];
                    }
                    for (let m = 0; m < 12; m++) {
                        const hue = ((g - 1) * 90 + m * 30) % 360;
                        colors[`gcd${g}_m${m}`] = `hsl(${hue}, 65%, 50%)`;
                    }
                }
                
                // Draw points
                Object.entries(pointsByColor).forEach(([colorKey, points]) => {
                    ctx.fillStyle = colors[colorKey] || '#999';
                    points.forEach(pt => {
                        ctx.beginPath();
                        ctx.arc(cx + pt.x*sc, cy - pt.y*sc, sz, 0, 2*Math.PI);
                        ctx.fill();
                    });
                });
                
                cache.points2D = { primitive: allPoints.filter(p => p.isPrimitive), 
                                   nonPrimitive: allPoints.filter(p => !p.isPrimitive), R };
                
                const pred = Math.round(Math.PI * R * R / zeta(2));
                const error = Math.abs(pred - prim);
                
                // Update stats based on view mode
                if (view2D === 'gauss') {
                    document.getElementById('p2').parentElement.querySelector('.lbl').textContent = 'Total Lattice Points';
                    animateValue('p2', 0, tot);
                    document.getElementById('t2').parentElement.querySelector('.lbl').textContent = 'Expected (πR²)';
                    animateValue('t2', 0, Math.round(Math.PI * R * R));
                    document.getElementById('d2').parentElement.querySelector('.lbl').textContent = 'Error';
                    document.getElementById('d2').textContent = Math.abs(tot - Math.PI * R * R).toFixed(1);
                    document.getElementById('e2').parentElement.querySelector('.lbl').textContent = '% of Expected';
                    document.getElementById('e2').textContent = ((tot / (Math.PI * R * R)) * 100).toFixed(2) + '%';
                } else {
                    document.getElementById('p2').parentElement.querySelector('.lbl').textContent = 'Primitive Points';
                    animateValue('p2', 0, prim);
                    document.getElementById('t2').parentElement.querySelector('.lbl').textContent = 'Total Points';
                    animateValue('t2', 0, tot);
                    document.getElementById('d2').parentElement.querySelector('.lbl').textContent = 'Density';
                    document.getElementById('d2').textContent = ((prim/tot)*100).toFixed(1) + '%';
                    document.getElementById('e2').parentElement.querySelector('.lbl').textContent = '|Predicted - Actual|';
                    animateValue('e2', 0, error);
                }
                
                document.getElementById('load2d').classList.remove('active');
            }, 100);
        }

        function init3D() {
            const c = document.getElementById('c3d');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
            camera = new THREE.PerspectiveCamera(75, c.clientWidth/600, 0.1, 1000);
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(c.clientWidth, 600);
            c.appendChild(renderer.domElement);
            
            const light1 = new THREE.AmbientLight(0xffffff, 0.6);
            const light2 = new THREE.DirectionalLight(0xffffff, 0.4);
            light2.position.set(1, 1, 1);
            scene.add(light1, light2);
            
            const axes = new THREE.AxesHelper(35);
            scene.add(axes);
            
            const canvas = renderer.domElement;
            canvas.addEventListener('mousedown', e => {
                mouseDown = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            canvas.addEventListener('mousemove', e => {
                if (mouseDown && !autoRotate) {
                    const dx = e.clientX - prevMouse.x;
                    const dy = e.clientY - prevMouse.y;
                    const rotSpeed = 0.005;
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), dx * rotSpeed);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
                    camera.position.applyAxisAngle(right, dy * rotSpeed);
                    camera.lookAt(0, 0, 0);
                    prevMouse = { x: e.clientX, y: e.clientY };
                }
            });
            canvas.addEventListener('mouseup', () => mouseDown = false);
            canvas.addEventListener('mouseleave', () => mouseDown = false);
            
            draw3D();
            animate3D();
        }

        function set3DShape(shape) {
            shape3D = shape;
            document.querySelectorAll('#shape3DSphere, #shape3DCube').forEach(btn => btn.classList.remove('active'));
            document.getElementById(shape === 'sphere' ? 'shape3DSphere' : 'shape3DCube').classList.add('active');
            draw3D();
        }

        function set3DColorMode(mode) {
            colorMode3D = mode;
            document.querySelectorAll('#colorPrimitive, #colorGCD, #colorMod, #colorOctant, #colorDistance, #colorGCDOct, #colorGCDMod').forEach(btn => btn.classList.remove('active'));
            const btnIds = {
                'primitive': 'colorPrimitive',
                'gcd': 'colorGCD',
                'mod': 'colorMod',
                'octant': 'colorOctant',
                'distance': 'colorDistance',
                'gcdoct': 'colorGCDOct',
                'gcdmod': 'colorGCDMod'
            };
            document.getElementById(btnIds[mode]).classList.add('active');
            
            // Show/hide modulus controls
            document.getElementById('modControls3D').style.display = (mode === 'mod' || mode === 'gcdmod') ? 'block' : 'none';
            
            draw3D();
        }

        function draw3D() {
            if (!scene) return;
            while(scene.children.length > 3) scene.remove(scene.children[3]);
            
            const R = parseInt(document.getElementById('r3').value);
            const pointSize = parseFloat(document.getElementById('ps3').value);
            document.getElementById('r3v').textContent = R;
            document.getElementById('ps3v').textContent = pointSize;
            document.getElementById('warn3d').style.display = R > 30 ? 'block' : 'none';
            
            if (R > 25) document.getElementById('load3d').classList.add('active');
            
            setTimeout(() => {
                // Add boundary shape
                if (shape3D === 'sphere') {
                    const sg = new THREE.SphereGeometry(R, 32, 32);
                    const sm = new THREE.MeshBasicMaterial({ 
                        color: 0x6f42c1, wireframe: true, transparent: true, opacity: 0.15 
                    });
                    scene.add(new THREE.Mesh(sg, sm));
                } else {
                    const boxGeometry = new THREE.BoxGeometry(2*R, 2*R, 2*R);
                    const edges = new THREE.EdgesGeometry(boxGeometry);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ 
                        color: 0x6f42c1, transparent: true, opacity: 0.3 
                    }));
                    scene.add(line);
                }
                
                // Collect all points with their properties
                const allPoints = [];
                let prim = 0, tot = 0;
                const modulus = parseInt(document.getElementById('mod3D').value);
                
                for (let x = -R; x <= R; x++) {
                    for (let y = -R; y <= R; y++) {
                        for (let z = -R; z <= R; z++) {
                            const distSq = x*x + y*y + z*z;
                            const inBounds = shape3D === 'sphere' ? 
                                (distSq <= R*R) : 
                                (Math.abs(x) <= R && Math.abs(y) <= R && Math.abs(z) <= R);
                            
                            if (inBounds) {
                                tot++;
                                const g = gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]);
                                const isPrimitive = g === 1;
                                if (isPrimitive) prim++;
                                
                                // Determine octant (1-8)
                                let octant = 1;
                                if (x >= 0 && y >= 0 && z >= 0) octant = 1;
                                else if (x < 0 && y >= 0 && z >= 0) octant = 2;
                                else if (x < 0 && y < 0 && z >= 0) octant = 3;
                                else if (x >= 0 && y < 0 && z >= 0) octant = 4;
                                else if (x >= 0 && y >= 0 && z < 0) octant = 5;
                                else if (x < 0 && y >= 0 && z < 0) octant = 6;
                                else if (x < 0 && y < 0 && z < 0) octant = 7;
                                else octant = 8;
                                
                                allPoints.push({
                                    x, y, z,
                                    gcd: g,
                                    isPrimitive,
                                    distance: Math.sqrt(distSq),
                                    sum: x + y + z,
                                    octant
                                });
                            }
                        }
                    }
                }
                
                cache.points3D = { 
                    primitive: allPoints.filter(p => p.isPrimitive),
                    nonPrimitive: allPoints.filter(p => !p.isPrimitive),
                    R 
                };
                
                // Color points based on mode
                const pointsByColor = {};
                
                allPoints.forEach(pt => {
                    let colorKey;
                    
                    switch(colorMode3D) {
                        case 'primitive':
                            colorKey = pt.isPrimitive ? 'prim' : 'nonprim';
                            break;
                        case 'gcd':
                            colorKey = `gcd${Math.min(pt.gcd, 8)}`;
                            break;
                        case 'mod':
                            colorKey = `mod${((pt.sum % modulus) + modulus) % modulus}`;
                            break;
                        case 'octant':
                            colorKey = `oct${pt.octant}`;
                            break;
                        case 'distance':
                            const distBucket = Math.floor(pt.distance / (R / 5));
                            colorKey = `dist${Math.min(distBucket, 5)}`;
                            break;
                        case 'gcdoct':
                            colorKey = `gcd${Math.min(pt.gcd, 4)}_oct${pt.octant}`;
                            break;
                        case 'gcdmod':
                            const modVal = ((pt.sum % modulus) + modulus) % modulus;
                            colorKey = `gcd${Math.min(pt.gcd, 4)}_m${modVal}`;
                            break;
                    }
                    
                    if (!pointsByColor[colorKey]) pointsByColor[colorKey] = [];
                    pointsByColor[colorKey].push(pt.x, pt.y, pt.z);
                });
                
                // Define color schemes
                const colorMap = {
                    prim: 0x0066cc,
                    nonprim: 0xdc3545,
                    gcd1: 0x0066cc, gcd2: 0xdc3545, gcd3: 0x28a745, gcd4: 0xffc107,
                    gcd5: 0x6f42c1, gcd6: 0xfd7e14, gcd7: 0x00d4ff, gcd8: 0xff006e,
                    oct1: 0x0066cc, oct2: 0xdc3545, oct3: 0x28a745, oct4: 0xffc107,
                    oct5: 0x6f42c1, oct6: 0xfd7e14, oct7: 0x00d4ff, oct8: 0xff006e,
                    dist0: 0x0066cc, dist1: 0x00d4ff, dist2: 0x28a745, 
                    dist3: 0xffc107, dist4: 0xfd7e14, dist5: 0xdc3545,
                    mod0: 0x0066cc, mod1: 0xdc3545, mod2: 0x28a745, mod3: 0xffc107,
                    mod4: 0x6f42c1, mod5: 0xfd7e14, mod6: 0x00d4ff, mod7: 0xff006e,
                    mod8: 0x20c997, mod9: 0xe83e8c, mod10: 0x17a2b8, mod11: 0x6610f2
                };
                
                // Generate combined colors
                const baseColors = [0x0066cc, 0xdc3545, 0x28a745, 0xffc107, 0x6f42c1, 0xfd7e14, 0x00d4ff, 0xff006e];
                for (let g = 1; g <= 4; g++) {
                    for (let o = 1; o <= 8; o++) {
                        colorMap[`gcd${g}_oct${o}`] = baseColors[(g - 1 + o - 1) % 8];
                    }
                    for (let m = 0; m < 12; m++) {
                        colorMap[`gcd${g}_m${m}`] = baseColors[(g - 1 + m) % 8];
                    }
                }
                
                // Create point groups
                Object.entries(pointsByColor).forEach(([colorKey, positions]) => {
                    if (positions.length > 0) {
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                        
                        const color = colorMap[colorKey] || 0x999999;
                        const material = new THREE.PointsMaterial({ color, size: pointSize });
                        scene.add(new THREE.Points(geometry, material));
                    }
                });
                
                const pred = Math.round(4 * Math.PI * R**3 / (3 * zeta(3)));
                const error = Math.abs(pred - prim);
                
                animateValue('p3', 0, prim);
                animateValue('t3', 0, tot);
                document.getElementById('d3').textContent = ((prim/tot)*100).toFixed(1) + '%';
                animateValue('e3', 0, error);
                
                document.getElementById('load3d').classList.remove('active');
            }, 100);
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if (renderer && scene && camera) {
                if (autoRotate) {
                    camera.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0.005);
                    camera.lookAt(0, 0, 0);
                }
                renderer.render(scene, camera);
            }
        }

        function reset3D() {
            if (camera) { 
                camera.position.set(50, 50, 50); 
                camera.lookAt(0, 0, 0); 
            }
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
            event.target.textContent = autoRotate ? 'Stop Rotation' : 'Auto-Rotate';
        }

        function setComparisonMode(mode) {
            comparisonMode = mode;
            document.querySelectorAll('#modeFixed, #modeMulti').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode === 'fixed' ? 'modeFixed' : 'modeMulti').classList.add('active');
            
            if (mode === 'fixed') {
                document.getElementById('fixedRadiusControls').style.display = 'block';
                document.getElementById('multiRadiusControls').style.display = 'none';
            } else {
                document.getElementById('fixedRadiusControls').style.display = 'none';
                document.getElementById('multiRadiusControls').style.display = 'block';
            }
            updateComparison();
        }

        function updateComparisonRadius(value) {
            const R = parseInt(value);
            if (R < 1 || R > 200 || isNaN(R)) return;
            
            document.getElementById('crv').textContent = R;
            document.getElementById('cr').value = Math.min(R, 100);
            document.getElementById('crinput').value = R;
            updateComparison();
        }

        function updateComparison() {
            const grid = document.getElementById('compGrid');
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            const showChart = document.getElementById('showChart').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                grid.innerHTML = '<p style="color:var(--red);">Please select at least one dimension</p>';
                return;
            }
            
            grid.innerHTML = '';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    const density = (1/z * 100).toFixed(2);
                    
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p style="font-size:1.1em;"><b>Predicted Points:</b> ${pred.toLocaleString()}</p>
                            </div>
                    `;
                    
                    if (showZeta) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showDensity) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Primitive Density:</b> ${density}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/ζ(${k}) = ${(1/z).toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showVolume) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Sphere Volume:</b></p>
                                <p style="font-size:0.95em;">${vol.toExponential(4)}</p>
                            </div>
                        `;
                    }
                    
                    // Add growth rate info
                    content += `
                        <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                            <p><b>Growth Rate:</b> O(R^${k})</p>
                            <p style="font-size:0.9em; color:var(--text2);">Error: O(R^${k-1})</p>
                        </div>
                    `;
                    
                    content += `</div>`;
                    grid.innerHTML += content;
                });
            } else {
                // Multiple radii mode
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                if (radii.length === 0) {
                    grid.innerHTML = '<p style="color:var(--red);">Please enter valid radii (e.g., 10, 20, 30)</p>';
                    return;
                }
                
                dims.forEach(k => {
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                    `;
                    
                    if (showZeta) {
                        const z = zeta(k);
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                                <p><b>Density:</b> ${((1/z)*100).toFixed(2)}%</p>
                            </div>
                        `;
                    }
                    
                    content += '<table style="width:100%; font-size:0.9em;"><thead><tr><th>R</th><th>Predicted</th>';
                    if (showVolume) content += '<th>Volume</th>';
                    content += '</tr></thead><tbody>';
                    
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / zeta(k));
                        content += `<tr><td>${R}</td><td>${pred.toLocaleString()}</td>`;
                        if (showVolume) content += `<td>${vol.toExponential(2)}</td>`;
                        content += '</tr>';
                    });
                    
                    content += '</tbody></table></div>';
                    grid.innerHTML += content;
                });
            }
            
            // Update chart
            if (showChart) {
                document.getElementById('comparisonChart').style.display = 'block';
                updateComparisonChart(dims);
            } else {
                document.getElementById('comparisonChart').style.display = 'none';
            }
        }

        function updateComparisonChart(dims) {
            const canvas = document.getElementById('compChart');
            const ctx = canvas.getContext('2d');
            
            if (comparisonChart) comparisonChart.destroy();
            
            const colors = ['#0066cc', '#ffc107', '#00d4ff', '#ff006e', '#28a745', '#6f42c1', '#fd7e14', '#dc3545', '#20c997'];
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                const data = dims.map(k => {
                    const vol = sphereVolume(k, R);
                    return Math.round(vol / zeta(k));
                });
                
                comparisonChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: dims.map(k => `k=${k}`),
                        datasets: [{
                            label: `Primitive Points (R=${R})`,
                            data: data,
                            backgroundColor: dims.map((k, i) => colors[i % colors.length]),
                            borderColor: dims.map((k, i) => colors[i % colors.length]),
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } }
                            },
                            x: {
                                title: { display: true, text: 'Dimension', font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: `Primitive Lattice Points Across Dimensions (R=${R})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
            } else {
                // Multiple radii - show lines
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                const datasets = dims.map((k, i) => {
                    const data = radii.map(R => {
                        const vol = sphereVolume(k, R);
                        return { x: R, y: Math.round(vol / zeta(k)) };
                    });
                    
                    return {
                        label: `k=${k}`,
                        data: data,
                        borderColor: colors[i % colors.length],
                        backgroundColor: colors[i % colors.length] + '33',
                        borderWidth: 2,
                        tension: 0.1,
                        fill: false
                    };
                });
                
                comparisonChart = new Chart(ctx, {
                    type: 'line',
                    data: { datasets },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                type: 'logarithmic',
                                title: { display: true, text: 'Number of Primitive Points', font: { size: 14 } }
                            },
                            x: {
                                title: { display: true, text: 'Radius R', font: { size: 14 } }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Primitive Lattice Points Growth Across Dimensions',
                                font: { size: 16, weight: 'bold' }
                            },
                            legend: { display: true }
                        }
                    }
                });
            }
        }

        function exportComparisonChart() {
            if (!comparisonChart) {
                alert('Please generate a comparison chart first');
                return;
            }
            exportCanvas('compChart', 'dimension-comparison-chart');
        }

        function updateComparison() {
            const grid = document.getElementById('compGrid');
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            const showChart = document.getElementById('showChart').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            if (dims.length === 0) {
                grid.innerHTML = '<p style="color:var(--red);">Please select at least one dimension</p>';
                return;
            }
            
            grid.innerHTML = '';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    const density = (1/z * 100).toFixed(2);
                    
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p style="font-size:1.1em;"><b>Predicted Points:</b> ${pred.toLocaleString()}</p>
                            </div>
                    `;
                    
                    if (showZeta) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showDensity) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Primitive Density:</b> ${density}%</p>
                                <p style="font-size:0.9em; color:var(--text2);">1/ζ(${k}) = ${(1/z).toFixed(6)}</p>
                            </div>
                        `;
                    }
                    
                    if (showVolume) {
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>Sphere Volume:</b></p>
                                <p style="font-size:0.95em;">${vol.toExponential(4)}</p>
                            </div>
                        `;
                    }
                    
                    // Add growth rate info
                    content += `
                        <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                            <p><b>Growth Rate:</b> O(R^${k})</p>
                            <p style="font-size:0.9em; color:var(--text2);">Error: O(R^${k-1})</p>
                        </div>
                    `;
                    
                    content += `</div>`;
                    grid.innerHTML += content;
                });
            } else {
                // Multiple radii mode
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                if (radii.length === 0) {
                    grid.innerHTML = '<p style="color:var(--red);">Please enter valid radii (e.g., 10, 20, 30)</p>';
                    return;
                }
                
                dims.forEach(k => {
                    let content = `
                        <div class="compare-item">
                            <h3 style="color:var(--blue); margin-bottom:15px;">Dimension k = ${k}</h3>
                    `;
                    
                    if (showZeta) {
                        const z = zeta(k);
                        content += `
                            <div style="background:var(--bg); padding:10px; border-radius:6px; margin-bottom:10px;">
                                <p><b>ζ(${k}):</b> ${z.toFixed(6)}</p>
                                <p><b>Density:</b> ${((1/z)*100).toFixed(2)}%</p>
                            </div>
                        `;
                    }
                    
                    content += '<table style="width:100%; font-size:0.9em;"><thead><tr><th>R</th><th>Predicted</th>';
                    if (showVolume) content += '<th>Volume</th>';
                    content += '</tr></thead><tbody>';
                    
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / zeta(k));
                        content += `<tr><td>${R}</td><td>${pred.toLocaleString()}</td>`;
                        if (showVolume) content += `<td>${vol.toExponential(2)}</td>`;
                        content += '</tr>';
                    });
                    
                    content += '</tbody></table></div>';
                    grid.innerHTML += content;
                });
            }
            
            // Update chart
            if (showChart) {
                document.getElementById('comparisonChart').style.display = 'block';
                updateComparisonChart(dims);
            } else {
                document.getElementById('comparisonChart').style.display = 'none';
            }
        }

        function updateAnalysisRadius(value) {
            const R = parseInt(value);
            if (R < 10 || R > 300 || isNaN(R)) return;
            
            document.getElementById('mrv').textContent = R;
            document.getElementById('mr').value = Math.min(R, 200);
            document.getElementById('mrinput').value = R;
        }

        function runAnalysis() {
            const canvas = document.getElementById('ch');
            const ctx = canvas.getContext('2d');
            const k = parseInt(document.getElementById('analysisK').value);
            const maxR = parseInt(document.getElementById('mrinput').value);
            const minR = parseInt(document.getElementById('minr').value);
            
            const showAbsError = document.getElementById('showAbsError').checked;
            const showRelError = document.getElementById('showRelError').checked;
            const showBoundary = document.getElementById('showBoundary').checked;
            const showActualCount = document.getElementById('showActualCount').checked;
            
            document.getElementById('loadAnalysis').classList.add('active');
            
            setTimeout(() => {
                if (chart) chart.destroy();
                
                const labels = [];
                const absErrorData = [];
                const relErrorData = [];
                const boundaryData = [];
                const actualCountData = [];
                
                // Compute for each radius from minR to maxR
                for (let R = minR; R <= maxR; R++) {
                    labels.push(R);
                    
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / zeta(k));
                    
                    let actual = pred; // Use prediction for large values
                    
                    // Only compute actual count for small enough cases
                    if (k === 2 && R <= 100) {
                        actual = 0;
                        for (let x = -R; x <= R; x++)
                            for (let y = -R; y <= R; y++)
                                if (x*x + y*y <= R*R && gcd(Math.abs(x), Math.abs(y)) === 1) actual++;
                    } else if (k === 3 && R <= 30) {
                        actual = 0;
                        for (let x = -R; x <= R; x++)
                            for (let y = -R; y <= R; y++)
                                for (let z = -R; z <= R; z++)
                                    if (x*x + y*y + z*z <= R*R && gcdArray([Math.abs(x), Math.abs(y), Math.abs(z)]) === 1) actual++;
                    }
                    
                    const absError = Math.abs(pred - actual);
                    const relError = pred > 0 ? (absError / pred) * 100 : 0;
                    const boundary = Math.pow(R, k - 1);
                    
                    absErrorData.push(absError);
                    relErrorData.push(relError);
                    boundaryData.push(boundary);
                    actualCountData.push(actual);
                }
                
                const datasets = [];
                
                if (showActualCount) {
                    datasets.push({
                        label: `Actual Primitive Count (k=${k})`,
                        data: actualCountData,
                        backgroundColor: 'rgba(0, 102, 204, 0.5)',
                        borderColor: '#0066cc',
                        borderWidth: 1,
                        type: 'bar',
                        yAxisID: 'y1',
                        order: 4
                    });
                }
                
                if (showAbsError) {
                    datasets.push({
                        label: `Absolute Error |Pred - Actual| (k=${k})`,
                        data: absErrorData,
                        backgroundColor: 'rgba(220, 53, 69, 0.6)',
                        borderColor: '#dc3545',
                        borderWidth: 2,
                        type: 'bar',
                        yAxisID: 'y',
                        order: 3
                    });
                }
                
                if (showRelError) {
                    datasets.push({
                        label: `Relative Error % (k=${k})`,
                        data: relErrorData,
                        backgroundColor: 'rgba(255, 193, 7, 0.6)',
                        borderColor: '#ffc107',
                        borderWidth: 2,
                        pointRadius: 3,
                        pointHoverRadius: 5,
                        type: 'line',
                        yAxisID: 'y2',
                        order: 2,
                        fill: false
                    });
                }
                
                if (showBoundary) {
                    datasets.push({
                        label: `Theoretical Boundary R^${k-1}`,
                        data: boundaryData,
                        backgroundColor: 'rgba(111, 66, 193, 0.3)',
                        borderColor: '#6f42c1',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        pointRadius: 2,
                        type: 'line',
                        yAxisID: 'y',
                        order: 1,
                        fill: false
                    });
                }
                
                const scales = {
                    x: { 
                        title: { display: true, text: 'Radius R', font: { size: 14 } }
                    },
                    y: {
                        type: 'logarithmic',
                        position: 'left',
                        title: { display: true, text: 'Count / Error', font: { size: 14 } },
                        display: showAbsError || showBoundary || showActualCount
                    }
                };
                
                if (showActualCount) {
                    scales.y1 = {
                        type: 'logarithmic',
                        position: 'right',
                        title: { display: true, text: 'Actual Count', font: { size: 14 } },
                        grid: { drawOnChartArea: false }
                    };
                }
                
                if (showRelError) {
                    scales.y2 = {
                        type: 'linear',
                        position: 'right',
                        title: { display: true, text: 'Relative Error %', font: { size: 14 } },
                        grid: { drawOnChartArea: false }
                    };
                }
                
                chart = new Chart(ctx, {
                    type: 'bar',
                    data: { labels, datasets },
                    options: { 
                        responsive: true,
                        maintainAspectRatio: true,
                        scales,
                        plugins: {
                            legend: { 
                                display: true,
                                position: 'top',
                                labels: { font: { size: 11 } }
                            },
                            title: {
                                display: true,
                                text: `Error Analysis per Radius (k=${k}, R=${minR} to ${maxR})`,
                                font: { size: 16, weight: 'bold' }
                            },
                            tooltip: { 
                                mode: 'index', 
                                intersect: false,
                                callbacks: {
                                    label: function(context) {
                                        let label = context.dataset.label || '';
                                        if (label) label += ': ';
                                        if (context.parsed.y !== null) {
                                            if (label.includes('%')) {
                                                label += context.parsed.y.toFixed(4) + '%';
                                            } else {
                                                label += context.parsed.y.toLocaleString(undefined, {
                                                    minimumFractionDigits: 0,
                                                    maximumFractionDigits: 2
                                                });
                                            }
                                        }
                                        return label;
                                    }
                                }
                            }
                        },
                        interaction: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                });
                
                document.getElementById('loadAnalysis').classList.remove('active');
            }, 100);
        }

        function set2DPreset(preset) {
            const presets = {
                'small': 10,
                'medium': 50,
                'large': 100,
                'xlarge': 200
            };
            update2DRadius(presets[preset]);
        }

        function set3DPreset(preset) {
            const presets = {
                'tiny': 5,
                'small': 10,
                'medium': 20,
                'large': 30
            };
            document.getElementById('r3').value = presets[preset];
            document.getElementById('r3v').textContent = presets[preset];
            draw3D();
        }

        function setComparisonPreset(preset) {
            // Uncheck all dimensions first
            for (let k = 2; k <= 10; k++) {
                const checkbox = document.getElementById(`compk${k}`);
                if (checkbox) checkbox.checked = false;
            }
            
            if (preset === 'low') {
                [2, 3, 4].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'mid') {
                [3, 4, 5, 6].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'high') {
                [5, 6, 7, 8, 9, 10].forEach(k => document.getElementById(`compk${k}`).checked = true);
            } else if (preset === 'all') {
                for (let k = 2; k <= 10; k++) {
                    document.getElementById(`compk${k}`).checked = true;
                }
            } else if (preset === 'growth') {
                setComparisonMode('multi');
                [2, 3, 4, 5].forEach(k => document.getElementById(`compk${k}`).checked = true);
                document.getElementById('multiRadii').value = '5, 10, 15, 20, 25, 30';
            }
            
            updateComparison();
        }

        function setAnalysisPreset(preset) {
            if (preset === 'quick') {
                updateAnalysisRadius(50);
            } else if (preset === 'standard') {
                updateAnalysisRadius(100);
            } else if (preset === 'detailed') {
                updateAnalysisRadius(150);
            } else if (preset === 'absolute') {
                document.getElementById('showAbsError').checked = true;
                document.getElementById('showRelError').checked = false;
                document.getElementById('showBoundary').checked = false;
                document.getElementById('showActualCount').checked = false;
            } else if (preset === 'relative') {
                document.getElementById('showAbsError').checked = false;
                document.getElementById('showRelError').checked = true;
                document.getElementById('showBoundary').checked = false;
                document.getElementById('showActualCount').checked = false;
            } else if (preset === 'boundary') {
                document.getElementById('showAbsError').checked = false;
                document.getElementById('showRelError').checked = false;
                document.getElementById('showBoundary').checked = true;
                document.getElementById('showActualCount').checked = false;
            }
            
            runAnalysis();
        }

        function setGCDPreset(preset) {
            const presets = {
                'coprime': '15, 28',
                'common': '12, 18, 24',
                'large': '1024, 2048, 4096',
                'many': '60, 72, 90, 120, 150'
            };
            document.getElementById('gi').value = presets[preset];
            calcGCD();
        }

        function setMobiusPreset(preset) {
            const presets = {
                'squarefree': 30,
                'notsquarefree': 72,
                'prime': 17,
                'composite': 210
            };
            document.getElementById('mi').value = presets[preset];
            calcMobius();
        }

        function setPrimePreset(preset) {
            const presets = {
                'small': 60,
                'perfect': 28,
                'highly': 5040,
                'large': 65536,
                'power': 243
            };
            document.getElementById('pi').value = presets[preset];
            calcPrime();
        }

        function setCoprimePreset(preset) {
            const presets = {
                'coprime2': '35, 64',
                'notcoprime2': '24, 36',
                'coprime3': '7, 11, 13',
                'consecutive': '100, 101, 102'
            };
            document.getElementById('cci').value = presets[preset];
            checkCoprime();
        }

        function setPointPreset(preset) {
            const presets = {
                'pythagorean': '3, 4, 5',
                'primitive2d': '7, 9',
                'nonprimitive2d': '6, 8',
                'primitive3d': '1, 2, 3',
                'highd': '1, 1, 1, 1, 1'
            };
            document.getElementById('psi').value = presets[preset];
            searchPoint();
        }

        function calcGCD() {
            const inp = document.getElementById('gi').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('gr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1 ? '<span style="color:var(--green)">✓ Coprime</span>' : '<span style="color:var(--red)">✗ Not Coprime</span>';
            
            // Show step-by-step GCD calculation for pairs
            let steps = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            steps += '<b>Step-by-step calculation:</b><br>';
            let current = nums[0];
            for (let i = 1; i < nums.length; i++) {
                const prev = current;
                current = gcd(current, nums[i]);
                steps += `gcd(${prev}, ${nums[i]}) = ${current}<br>`;
            }
            steps += '</div>';
            
            // Prime factorizations
            let factorizations = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            factorizations += '<b>Prime factorizations:</b><br>';
            nums.forEach(n => {
                const f = primeFactors(Math.abs(n));
                const fc = {};
                f.forEach(p => fc[p] = (fc[p]||0) + 1);
                const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorizations += `${n} = ${fs || '1'}<br>`;
            });
            
            // GCD factorization
            if (g > 1) {
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorizations += `<br><b>GCD = ${g} = ${gfs}</b>`;
            }
            factorizations += '</div>';
            
            document.getElementById('gr').innerHTML = `
                <p><b>Numbers:</b> ${nums.join(', ')}</p>
                <p><b>GCD:</b> ${g}</p>
                <p>${coprime}</p>
                ${steps}
                ${factorizations}
            `;
        }

        function calcMobius() {
            const n = parseInt(document.getElementById('mi').value);
            if (!n || n < 1) return;
            const mu = mobius(n), f = primeFactors(n);
            const u = [...new Set(f)];
            const sqfree = f.length === u.length;
            const interp = mu === 0 ? 'Not square-free (has repeated prime factors)' : mu === 1 ? 'Even number of distinct prime factors' : 'Odd number of distinct prime factors';
            
            // Build prime factorization display
            const fc = {};
            f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
            const repeatedPrimes = Object.entries(fc).filter(([p,c]) => c > 1).map(([p,c]) => `${p} (appears ${c} times)`);
            
            let details = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            details += `<b>Prime factorization:</b> ${n} = ${fs || '1'}<br>`;
            details += `<b>Distinct primes:</b> {${u.join(', ')}}<br>`;
            details += `<b>Number of distinct primes:</b> ${u.length}<br>`;
            if (repeatedPrimes.length > 0) {
                details += `<b>Repeated primes:</b> ${repeatedPrimes.join(', ')}<br>`;
            }
            details += `<b>Square-free:</b> ${sqfree ? '✓ Yes' : '✗ No'}<br>`;
            details += '</div>';
            
            let formula = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            formula += '<b>Formula calculation:</b><br>';
            if (mu === 0) {
                formula += `μ(${n}) = 0 (not square-free)<br>`;
            } else {
                formula += `μ(${n}) = (-1)^${u.length} = (-1)^${u.length} = ${mu}<br>`;
            }
            formula += '</div>';
            
            document.getElementById('mr2').innerHTML = `
                <p style="font-size:1.3em;"><b>μ(${n}) = ${mu}</b></p>
                <p style="color:var(--blue);"><b>${interp}</b></p>
                ${details}
                ${formula}
            `;
        }

        function calcPrime() {
            const n = parseInt(document.getElementById('pi').value);
            if (!n || n < 2) return;
            const f = primeFactors(n);
            const fc = {};
            f.forEach(p => fc[p] = (fc[p]||0) + 1);
            const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
            
            let details = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            details += '<b>Detailed breakdown:</b><br>';
            details += `<b>All prime factors:</b> ${f.join(' × ')}<br>`;
            details += `<b>Distinct primes:</b> ${Object.keys(fc).join(', ')}<br>`;
            details += `<b>Number of distinct primes:</b> ${Object.keys(fc).length}<br>`;
            details += `<b>Total number of prime factors (with repetition):</b> ${f.length}<br>`;
            
            // Show exponent breakdown
            details += '<br><b>Exponent breakdown:</b><br>';
            Object.entries(fc).forEach(([p, c]) => {
                details += `${p} appears ${c} time${c > 1 ? 's' : ''}<br>`;
            });
            
            // Divisor information
            const numDivisors = Object.values(fc).reduce((prod, exp) => prod * (exp + 1), 1);
            details += `<br><b>Number of divisors:</b> ${numDivisors}<br>`;
            
            // Sum of divisors (for small numbers)
            if (n <= 1000) {
                let sumDiv = 0;
                for (let i = 1; i <= n; i++) {
                    if (n % i === 0) sumDiv += i;
                }
                details += `<b>Sum of divisors:</b> ${sumDiv}<br>`;
                const perfect = sumDiv === 2 * n;
                const abundant = sumDiv > 2 * n;
                const deficient = sumDiv < 2 * n;
                details += `<b>Number type:</b> ${perfect ? 'Perfect' : abundant ? 'Abundant' : 'Deficient'}<br>`;
            }
            
            details += '</div>';
            
            document.getElementById('pr').innerHTML = `
                <p style="font-size:1.3em;"><b>${n} = ${fs}</b></p>
                <p style="font-size:1.1em;">${isPrime(n) ? '<span style="color:var(--green)">✓ PRIME NUMBER</span>' : '<span style="color:var(--blue)">COMPOSITE NUMBER</span>'}</p>
                ${details}
            `;
        }

        function checkCoprime() {
            const inp = document.getElementById('cci').value;
            const nums = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (nums.length < 2) {
                document.getElementById('ccr').innerHTML = '<p style="color:var(--red)">Need 2+ numbers</p>';
                return;
            }
            const g = gcdArray(nums);
            const coprime = g === 1;
            
            // Prime factorizations
            let factorInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            factorInfo += '<b>Prime factorizations:</b><br>';
            nums.forEach(n => {
                const f = primeFactors(Math.abs(n));
                const fc = {};
                f.forEach(p => fc[p] = (fc[p]||0) + 1);
                const fs = Object.entries(fc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                factorInfo += `${n} = ${fs || '1'}<br>`;
            });
            factorInfo += '</div>';
            
            // Common factors
            let commonInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            if (coprime) {
                commonInfo += '<b>Common factors:</b> Only 1 (coprime)<br>';
                commonInfo += 'These numbers share no prime factors.';
            } else {
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                commonInfo += `<b>Common factors:</b> Divisors of ${g}<br>`;
                commonInfo += `<b>GCD breakdown:</b> ${g} = ${gfs}<br>`;
                commonInfo += `<b>Shared primes:</b> ${Object.keys(gfc).join(', ')}`;
            }
            commonInfo += '</div>';
            
            document.getElementById('ccr').innerHTML = `
                <p><b>Numbers:</b> ${nums.join(', ')}</p>
                <p><b>GCD:</b> ${g}</p>
                <p style="font-size:1.2em; margin-top:10px">${coprime ? '<span style="color:var(--green)">✓ COPRIME (Primitive point)</span>' : '<span style="color:var(--red)">✗ NOT COPRIME (Non-primitive)</span>'}</p>
                ${factorInfo}
                ${commonInfo}
            `;
        }

        function searchPoint() {
            const inp = document.getElementById('psi').value;
            const coords = inp.split(',').map(n => parseInt(n.trim())).filter(n => !isNaN(n));
            if (coords.length < 2) {
                document.getElementById('psr').innerHTML = '<p style="color:var(--red)">Need 2+ coordinates</p>';
                return;
            }
            const g = gcdArray(coords);
            const isPrim = g === 1;
            const dist = Math.sqrt(coords.reduce((sum, x) => sum + x*x, 0));
            
            // Point factorization
            let pointInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            pointInfo += '<b>Coordinate factorizations:</b><br>';
            coords.forEach((c, i) => {
                const label = ['x', 'y', 'z', 'w', 'v', 'u'][i] || `x${i}`;
                if (c === 0) {
                    pointInfo += `${label} = 0<br>`;
                } else {
                    const f = primeFactors(Math.abs(c));
                    const fc = {};
                    f.forEach(p => fc[p] = (fc[p]||0) + 1);
                    const fs = Object.entries(fc).map(([p,cnt]) => cnt>1 ? `${p}^${cnt}` : p).join(' × ');
                    const sign = c < 0 ? '-' : '';
                    pointInfo += `${label} = ${sign}${fs || '1'}<br>`;
                }
            });
            pointInfo += '</div>';
            
            // GCD analysis
            let gcdInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            if (g === 1) {
                gcdInfo += '<b>GCD Analysis:</b><br>';
                gcdInfo += 'GCD = 1 → Coordinates are coprime<br>';
                gcdInfo += 'This point cannot be expressed as d·(simpler point) where d > 1';
            } else {
                const reduced = coords.map(c => c / g);
                const gf = primeFactors(g);
                const gfc = {};
                gf.forEach(p => gfc[p] = (gfc[p]||0) + 1);
                const gfs = Object.entries(gfc).map(([p,c]) => c>1 ? `${p}^${c}` : p).join(' × ');
                gcdInfo += '<b>GCD Analysis:</b><br>';
                gcdInfo += `GCD = ${g} = ${gfs}<br>`;
                gcdInfo += `<b>Reduced form:</b> (${reduced.join(', ')}) is the primitive point<br>`;
                gcdInfo += `<b>Relationship:</b> (${coords.join(', ')}) = ${g} × (${reduced.join(', ')})`;
            }
            gcdInfo += '</div>';
            
            // Geometric properties
            let geomInfo = '<div style="background:var(--bg3); padding:15px; border-radius:8px; margin-top:10px;">';
            geomInfo += '<b>Geometric Properties:</b><br>';
            geomInfo += `<b>Euclidean norm:</b> ||point|| = √(${coords.map(c => c + '²').join(' + ')}) = ${dist.toFixed(4)}<br>`;
            geomInfo += `<b>Manhattan distance:</b> ${coords.reduce((sum, c) => sum + Math.abs(c), 0)}<br>`;
            geomInfo += `<b>Max coordinate:</b> ${Math.max(...coords.map(Math.abs))}<br>`;
            const numZeros = coords.filter(c => c === 0).length;
            if (numZeros > 0) {
                geomInfo += `<b>Zero coordinates:</b> ${numZeros} (lies on ${coords.length - numZeros}D subspace)`;
            }
            geomInfo += '</div>';
            
            document.getElementById('psr').innerHTML = `
                <p><b>Point:</b> (${coords.join(', ')})</p>
                <p><b>Dimension:</b> ${coords.length}</p>
                <p><b>GCD of coordinates:</b> ${g}</p>
                <p style="font-size:1.2em; margin-top:10px">${isPrim ? '<span style="color:var(--green)">✓ PRIMITIVE LATTICE POINT</span>' : '<span style="color:var(--red)">✗ NON-PRIMITIVE LATTICE POINT</span>'}</p>
                ${pointInfo}
                ${gcdInfo}
                ${geomInfo}
            `;
        }

        function exportCanvas(canvasId, filename) {
            const canvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = `${filename}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function exportPointData2D() {
            if (!cache.points2D) { alert('Generate 2D visualization first'); return; }
            const data = cache.points2D;
            let csv = 'x,y,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},non-primitive\n`);
            downloadCSV(csv, '2d-lattice-points.csv');
        }

        function export3DData() {
            if (!cache.points3D) { alert('Generate 3D visualization first'); return; }
            const data = cache.points3D;
            let csv = 'x,y,z,type\n';
            data.primitive.forEach(p => csv += `${p.x},${p.y},${p.z},primitive\n`);
            data.nonPrimitive.forEach(p => csv += `${p.x},${p.y},${p.z},non-primitive\n`);
            downloadCSV(csv, '3d-lattice-points.csv');
        }

        function exportTheoryData() {
            const k = parseInt(document.getElementById('tks').value);
            const R = parseInt(document.getElementById('trs').value);
            const z = zeta(k);
            const vol = sphereVolume(k, R);
            const pred = Math.round(vol / z);
            
            let csv = 'dimension,radius,zeta,density,volume,predicted_points\n';
            csv += `${k},${R},${z},${1/z},${vol},${pred}\n`;
            downloadCSV(csv, 'theory-data.csv');
        }

        function exportChartData() {
            if (!chart) { alert('Run analysis first'); return; }
            const data = chart.data.datasets[0].data;
            let csv = 'radius,error\n';
            data.forEach(pt => csv += `${pt.x},${pt.y}\n`);
            downloadCSV(csv, 'error-analysis.csv');
        }

        function exportComparisonData() {
            const showDensity = document.getElementById('showDensity').checked;
            const showVolume = document.getElementById('showVolume').checked;
            const showZeta = document.getElementById('showZeta').checked;
            
            const dims = [];
            for (let k = 2; k <= 10; k++) {
                if (document.getElementById(`compk${k}`)?.checked) dims.push(k);
            }
            
            let csv = 'dimension,';
            if (comparisonMode === 'fixed') {
                csv += 'radius,';
            }
            if (showZeta) csv += 'zeta,';
            if (showDensity) csv += 'density,';
            csv += 'predicted_points';
            if (showVolume) csv += ',volume';
            csv += '\n';
            
            if (comparisonMode === 'fixed') {
                const R = parseInt(document.getElementById('crinput').value);
                dims.forEach(k => {
                    const z = zeta(k);
                    const vol = sphereVolume(k, R);
                    const pred = Math.round(vol / z);
                    csv += `${k},${R},`;
                    if (showZeta) csv += `${z},`;
                    if (showDensity) csv += `${1/z},`;
                    csv += `${pred}`;
                    if (showVolume) csv += `,${vol}`;
                    csv += '\n';
                });
            } else {
                const radiiStr = document.getElementById('multiRadii').value;
                const radii = radiiStr.split(',').map(r => parseInt(r.trim())).filter(r => !isNaN(r) && r > 0);
                
                dims.forEach(k => {
                    const z = zeta(k);
                    radii.forEach(R => {
                        const vol = sphereVolume(k, R);
                        const pred = Math.round(vol / z);
                        csv += `${k},${R},`;
                        if (showZeta) csv += `${z},`;
                        if (showDensity) csv += `${1/z},`;
                        csv += `${pred}`;
                        if (showVolume) csv += `,${vol}`;
                        csv += '\n';
                    });
                });
            }
            
            downloadCSV(csv, 'dimension-comparison.csv');
        }

        function downloadCSV(content, filename) {
            const blob = new Blob([content], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            URL.revokeObjectURL(url);
        }

        function toggleDark() {
            document.body.classList.toggle('light');
            const btn = document.getElementById('darkBtn');
            btn.textContent = document.body.classList.contains('light') ? 'Dark Mode' : 'Light Mode';
            if (scene) scene.background = new THREE.Color(document.body.classList.contains('light') ? 0xffffff : 0x1a1a1a);
        }

        function showHelp() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelp() {
            document.getElementById('helpModal').classList.remove('active');
        }

        function showDerivationAnimation() {
            alert('Interactive animation coming soon! This would show step-by-step how Möbius inversion leads to the zeta function connection.');
        }

        // Init
        updateTheory();
        const tb = document.getElementById('tbl');
        for (let k = 2; k <= 12; k++) {
            const z = zeta(k);
            const v = k % 2 === 0 ? 
                (Math.PI**(k/2) / factorial(k/2)).toFixed(4) :
                (2 * factorial((k-1)/2) * Math.PI**((k-1)/2) / factorial(k)).toFixed(4);
            tb.innerHTML += `<tr><td>${k}</td><td>${z.toFixed(4)}</td><td>${(1/z).toFixed(4)}</td><td>${v}</td></tr>`;
        }
        
        document.getElementById('helpModal').addEventListener('click', e => {
            if (e.target.id === 'helpModal') closeHelp();
        });
    </script>
</body>
    </html>
